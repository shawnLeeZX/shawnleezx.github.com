<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Note | SHAWN LEE]]></title>
  <link href="http://shawnLeeZX.github.io/blog/categories/note/atom.xml" rel="self"/>
  <link href="http://shawnLeeZX.github.io/"/>
  <updated>2015-08-05T10:45:43+08:00</updated>
  <id>http://shawnLeeZX.github.io/</id>
  <author>
    <name><![CDATA[Shawn]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[On IDEs of Python in Emacs]]></title>
    <link href="http://shawnLeeZX.github.io/blog/2015/08/05/on-ides-of-python-in-emacs/"/>
    <updated>2015-08-05T10:30:00+08:00</updated>
    <id>http://shawnLeeZX.github.io/blog/2015/08/05/on-ides-of-python-in-emacs</id>
    <content type="html"><![CDATA[<p>I was finally annoyed enough to find a replacement of <code>auto-complete</code> in
Emacs. Reasons will be noted down later. In this note, three common extensions
for writing Python under Emacs will be compared and noted, which are:</p>

<ol>
  <li><a href="https://github.com/tkf/emacs-jedi">jedi</a></li>
  <li><a href="https://github.com/jorgenschaefer/elpy">elpy</a></li>
  <li><a href="https://github.com/proofit404/anaconda-mode">anaconda</a></li>
</ol>

<!-- more -->

<p>I always used emacs-jedi since I made the shift from Vim to Emacs.</p>

<p>The functionality provided by emacs-jedi is actually quite good. The only function
that lacks is the one to refactor. So it is not the fault of emacs-jedi that makes me
want to change extensions. However, the detail will be left to the comparison
between <code>company-mode</code> and <code>auto-complete</code>.</p>

<p>Though emacs-jedi is not bad, it is also not that good compared with elpy, in my
opinion.</p>

<p>You could get good code completion, etc, basically everything roughly equal in
those three extensions. There are some details about elpy that makes me prefer
to elpy.</p>

<p>At the time that I set up emacs-jedi, basically I copied some the author’s hacking
code to let emacs-jedi recognize my current python files, or project
automatically. It works, but it does not feel elegant.</p>

<p>I could get by with that if it is not due to the reason of <code>auto-complete</code>.</p>

<p>With elpy, you could use command <code>elpy-set-project-root</code> to tell elpy that you
need current project to be taken into account, which does not feel
automatically but it is more user friendly and elegant.</p>

<p>What’s more, elpy takes into account the <code>PYTHON_PATH</code> environment variable
into account automatically. I guess emacs-jedi does this as well.</p>

<p>As for anaconda, actually I found it prior to elpy and also gave it a
try. However, it failed when I tried to get code completion on-the-fly in my
current project and no documentation seems to hint me how to deal with that.</p>

<p>Lastly, the refactoring function provided by elpy seems exciting so that I
won’t need to use <code>search-and-replace</code> or <code>multi-occur</code> stuff. But I did not
try it yet. Look forward to.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Some Notes on IPython Startup Script]]></title>
    <link href="http://shawnLeeZX.github.io/blog/2015/08/03/some-notes-on-ipython-startup-script/"/>
    <updated>2015-08-03T16:22:00+08:00</updated>
    <id>http://shawnLeeZX.github.io/blog/2015/08/03/some-notes-on-ipython-startup-script</id>
    <content type="html"><![CDATA[<p>This post is going to note down how to let ipython automatically reload a
module after changing the module and how to run magic function from python
start-up scripts.</p>

<!-- more -->

<p>ipython will not reload any modules if you have changed some module under given
that ipython want to keep the interactive session so all your data during the
session is going to be kept. To overcome this situation while you are writing
some module or library code, the <code>autoload</code> magic function could be used.</p>

<p>```python
%load_ext autoreload</p>

<p>%autoreload 2
```</p>

<p>```bash
%autoreload
Reload all modules (except those excluded by %aimport) automatically now.</p>

<p>%autoreload 0
Disable automatic reloading.</p>

<p>%autoreload 1
Reload all modules imported with %aimport every time before executing the Python code typed.</p>

<p>%autoreload 2
Reload all modules (except those excluded by %aimport) every time before executing the Python code typed.</p>

<p>%aimport
List modules which are to be automatically imported or not to be imported.</p>

<p>%aimport foo
Import module ‘foo’ and mark it to be autoreloaded for %autoreload 1</p>

<p>%aimport -foo
Mark module ‘foo’ to not be autoreloaded.
```</p>

<p>For more details, refer to ipython’s
<a href="http://ipython.org/ipython-doc/dev/config/extensions/autoreload.html">documentation</a>.</p>

<p>To avoid typing those magic function again and again, they could be put in the
ipython startup script(Name it with <code>.py</code> suffix under
<code>.ipython/profile_default/startup</code>. All python scripts under that folder will
be loaded according to lexical order), which looks like the following:</p>

<p>```python
from IPython import get_ipython
ipython = get_ipython()</p>

<p>ipython.magic(“pylab”)
ipython.magic(“load_ext autoreload”)
ipython.magic(“autoreload 2”)
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Add Text to Scanned Pdf Without Text]]></title>
    <link href="http://shawnLeeZX.github.io/blog/2015/07/14/how-to-add-text-to-scanned-pdf-without-text/"/>
    <updated>2015-07-14T10:43:00+08:00</updated>
    <id>http://shawnLeeZX.github.io/blog/2015/07/14/how-to-add-text-to-scanned-pdf-without-text</id>
    <content type="html"><![CDATA[<p>I am reading some paper that is decades ago so no pdf file with text could
found, so I looked up to some solution. Here it is.</p>

<!-- more -->

<p><a href="https://github.com/gkovacs/pdfocr">Pdfocr</a> is a ruby script that integrates
open source tools to add text layer to pdf files.</p>

<p>To be able to use it, there are some dependence needed, just as shell scripts.</p>

<p><code>bash
sudo apt-get install pdftk
sudo apt-get install tesseract-ocr tesseract-ocr-eng exactimage
</code></p>

<p>You can infer what those programs are used for based what the author
<a href="http://ubuntuforums.org/showthread.php?t=1456756">said</a> below.</p>

<blockquote>
  <p>pdfocr was written by me (Geza Kovacs). It is simply a script which automates
the following process:</p>

  <ol>
    <li>Splitting the PDF file into separate pages using pdftk</li>
    <li>Extracting out the image data using pdfimages</li>
    <li>Doing OCR (optical character recognition) using cuneiform</li>
    <li>Embedding the detected text back into the PDF file using hocr2pdf</li>
    <li>Merging together the files using pdftk.</li>
  </ol>
</blockquote>

<p>Lastly, clone the ruby code.</p>

<p><code>bash
git clone https://github.com/gkovacs/pdfocr
</code></p>

<p>Then enjoy.</p>

<p><code>bash
pdfocr.rb -i foo.pdf -o out.pdf
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Zoom In and Out Gnome Using Mouse]]></title>
    <link href="http://shawnLeeZX.github.io/blog/2015/07/02/zoom-in-and-out-gnome-using-mouse/"/>
    <updated>2015-07-02T17:18:00+08:00</updated>
    <id>http://shawnLeeZX.github.io/blog/2015/07/02/zoom-in-and-out-gnome-using-mouse</id>
    <content type="html"><![CDATA[<p>Just tried to find a solution to zoom in and out in the GNOME desktop, so that
things could be seen better in case they are too small during presentation.</p>

<!-- more -->

<p>The solution a program called <code>mousewheelzoom</code>, whose source is held at github:
<a href="https://github.com/tobiasquinn/gnome-shell-mousewheel-zoom">gnome-shell-mousewheel-zoom</a>.</p>

<p>The installation instructions could be found there.</p>

<hr />

<p>Besides the solution that works, two solutions that did not work are also going
to noted below.</p>

<h3 id="compiz-setting">Compiz Setting</h3>

<p>At first I tried to changing setting in Compizconfig Settingsmanager, as
suggested in the
<a href="http://askubuntu.com/questions/82398/how-to-zoom-inzoom-out">link</a>. It turns
out that compiz is used by Unity, not GNOME. Since I have changed the desktop
environment, it does not obviously.</p>

<h3 id="gnome-native-solution">GNOME Native solution</h3>

<p>Then GNOME also offers such function directly in their <em>Universal Access</em>,
under <em>Seeing</em> tab, in category Zoom — just type Universal Access in the
Dock. However, it does not work either.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Connection between PCA and Fourier Transform]]></title>
    <link href="http://shawnLeeZX.github.io/blog/2015/06/05/connection-between-pca/"/>
    <updated>2015-06-05T21:10:00+08:00</updated>
    <id>http://shawnLeeZX.github.io/blog/2015/06/05/connection-between-pca</id>
    <content type="html"><![CDATA[<!-- more -->

<p>When we are running PCA on images, the first principle component we get is
normally looks like the DC term, which is the first Fourier bases of
images. After some analysis, I found that this makes a lot of sense.</p>

<p>We could unify PCA and Fourier Transform from filter bank or linear operator
point of view. Actually those two point of views are just different way to say
the same thing in signal processing and mathematics.</p>

<p>From filter bank point of view, the process of getting the PCA coefficients and
Fourier coefficients could be regarded as passing the original signal to a
Linear Time Invariant system. Each Fourier basis or eigenvector is a
filter. All of them make up the filter bank.</p>

<p>From linear operator point of view, such process could be taken as an operator
to project the point in one space to another space.</p>

<p>It turns out that Fourier basis $e^{i\omega t}$ and eigenvector $v$ of covariance
matrix are both eigenvector(this eigenvector is not specific to the eigenvector
computed from covariance matrix of the data) of the LTI system.</p>

<p>The Fourier basis eigenvectors could be taken as the eigenvector of covariance
of all possible images that could be formed by spatial complex exponential
signal. So it is fixed. As for the data driven eigenvector $v$, it is only the
eigenvector of that amount of data. They are both orthogonal with other
eigenvectors within their sets. If data driven eigenvector get normalized, it
has unit norm as well.</p>

<p>This could explain why the first principal components of covariance looks a lot
similar do the first Fourier basis. Because DC term of images affect all
pixels, naming all dimensions. So its variance is the largest, which makes it
similar with first fourier basis. I think similar argument could be made to
other principal components and Fourier bases as well. But they may be less
obvious then the first one.</p>
]]></content>
  </entry>
  
</feed>
