<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Note | SHAWN LEE]]></title>
  <link href="http://shawnLeeZX.github.io/blog/categories/note/atom.xml" rel="self"/>
  <link href="http://shawnLeeZX.github.io/"/>
  <updated>2016-07-30T09:12:06+08:00</updated>
  <id>http://shawnLeeZX.github.io/</id>
  <author>
    <name><![CDATA[Shawn]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Note On Representation of Operator]]></title>
    <link href="http://shawnLeeZX.github.io/blog/2016/05/01/note-on-representation-of-operator/"/>
    <updated>2016-05-01T17:02:00+08:00</updated>
    <id>http://shawnLeeZX.github.io/blog/2016/05/01/note-on-representation-of-operator</id>
    <content type="html"><![CDATA[<p>A note to remind me of some intuition ruminated. Do not have the time to write
down detailed proof.</p>

<p>It is about spectral theorem of matrix, adjoint operator, SVD and tensor.</p>

<!-- more -->

<h2 id="spectral-theorem">Spectral Theorem</h2>

<p>The representation theory of linear functional is essentially one dimension
version of group representation theory. The $w$ in the inner product $\langle
x, w \rangle$ representation of functional $f(x)$ is essentially the normal of
the hyperplane, which is the functional’s representation in the dual space. The
process of applying $f$ on $x$ is a process of projection.</p>

<p>For a general operator $T: X \rightarrow Y$, whose representation is denoted
$A$, if the bases of the $X, Y$ are orthogonal, the adjoint operator $T^{*}$ of
$T$’s representation is $A^{T}$(on the condition that bases of $X, Y$ is chosen
to be orthogonal). The process of applying $T$ on $x$ is a process of first
doing multiple projection, then sum those projection together. The fact that
adjoint operator has the spectral theorem is just because in certain bases,
when we are applying the multiple projection, we are not projecting at all, but
just scale along the hyperplane. The process of changing bases, applying
scaling, then changing bases back written in form of matrix multiplication is
$M^{-1}\Lambda M$, which is the spectral decomposition of representation of $T$.</p>

<h2 id="adjoint-operator-is-just-the-transpose">Adjoint Operator is Just the Transpose</h2>

<p>The projection perspective also explains why $T^{*} = A^{T}$.</p>

<p>Let $Ax = y$. Each $x_i$ contributes to $y_i$ linearly. So just like a linear
equation has a unique solution as long as $A$ is of full rank, there must be a
one-to-one relationship between $T$ and $T^{*}$, which is formalized using
representation theory of functional again.</p>

<h2 id="svd">SVD</h2>

<p>SVD just factorizes the multi-projection into a rotation matrix and a scaling
matrix.</p>

<h2 id="tensor">Tensor</h2>

<p>Tensor is a generalized operator that handles multi-linearity.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A Quick Survey on Distributed Log Processing: Unison and Logstash]]></title>
    <link href="http://shawnLeeZX.github.io/blog/2016/03/15/a-quick-survey-on-log-processing/"/>
    <updated>2016-03-15T10:53:00+08:00</updated>
    <id>http://shawnLeeZX.github.io/blog/2016/03/15/a-quick-survey-on-log-processing</id>
    <content type="html"><![CDATA[<p>Having multiple machines to train neural networks, I was trying to think how
could I automatically gather all the training logs, so I could analyze them in
one place.</p>

<p>I did a survey on technologies available. The ones that I found are: <code>Logstash</code>
and <code>unison</code>. <code>Logstash</code> seems to be the optimal solution, though may be a little
an overkill. However, I settled to use <code>unison</code> in the end. The rationale
behind this is I have to get around many VPNs. The VPNs I used, or maybe most
VPNs setups, won’t let the machines in LAN of the VPN network ping back to the
machine that uses VPN to connect. It may just not come from a security reason,
though it could be; it may just because it is not necessary to set up the route
table to the IP addresses allocated to the connecting machine. So in this case,
the log cannot be sent back to the connecting machine, as the way <code>Logstash</code>
does. A solution is needed to initialize the centralization from the connect
machine site. So <code>Logstash</code> is ruled out, and I settled with <code>unison</code>.</p>

<p>The following is a quick note on <code>unison</code> works, which took me a while to
figure out. For an practical introduction to <code>Logstash</code>, see the
<a href="http://www.slashroot.in/logstash-tutorial-linux-central-logging-server">tutorial</a>
here.</p>

<!-- more -->

<h2 id="introductory-note">Introductory Note</h2>

<p><a href="http://www.cis.upenn.edu/~bcpierce/unison/download/releases/stable/unison-manual.html#basics">Unison</a>
is a file-synchronization tool for Unix and Windows. It allows two replicas of
a collection of files and directories to be stored on different hosts (or
different disks on the same host), modified separately, and then brought up to
date by propagating the changes in each replica to the other.</p>

<p><code>Unison</code> supports transmission via <code>ssh</code>, <code>socket</code>, <code>file</code> and <code>rsh</code>. Each of
those protocols has its own setups, except for the <code>file</code> protocol — it
synchronizes files within the single machine. For instance, to use ssh, the two
machines to be able to ssh to each other.</p>

<p>The way <code>unison</code> is used is similar with <code>scp</code> or <code>cp</code> in the sense that they
are all a command line source destination style. An example would be</p>

<p><code>bash
unison -testserver /tmp/ ssh://192.168.72.1//tmp
</code></p>

<p>The format of a source or destination is
<code>[protocol:]//[user@][host][:port][/path]</code>. The one with no host name is
supposed to your local machine. The <code>-testserver</code> option above is used to test
whether the network between the local machine and the remote machine is
reachable.</p>

<p>To avoid typing the addresses each time, since <code>unison</code> is about syncing, not
copying, <code>unison</code> offers a thing called profile. The command above, without the
<code>-testserver</code> option, converts to a profile is</p>

<p><code>
root = /home/use1/work/sync/
root = ssh://192.168.72.1//home/user1/work/sync
</code></p>

<p>For more sophisticated profiles, see the office
<a href="http://www.cis.upenn.edu/~bcpierce/unison/download/releases/stable/unison-manual.html#profile">doc</a>.</p>

<p>The question following is where do we store profiles?</p>

<p><code>unison</code> will store all its logistics files under the folder pointed by
environment variable <code>UNISON</code>, which if not specified, is <code>.unison</code> under the
<code>$HOME</code> folder. A profile file us named in the format of <code>*.prf</code>. Suppose the
above profile is saved as <code>test.prf</code>. To use that profile, type</p>

<p><code>bash
unison test
</code></p>

<p>The last thing I spent some time to figure out is how it actually sync between
machines, so it won’t mess up my data. Roughly, it adds another layer of logic
above <code>rsync</code>, which is suggested from the document</p>

<pre><code>Transfers are optimised using a version of the rsync protocol, making it ideal
for slower links. Unison has a clear and precise specification, and is
resilient to failure due to its careful handling of the replicas and its
private structures.
</code></pre>

<p>The logic is added I think is the way to get some fingerprints of the files, so
it knows which files is updated when syncing, and only sync those are really updated.</p>

<pre><code>Touching a file without changing its contents should never affect whether or
not Unison does an update. (When running with the fastcheck preference set to
true—the default on Unix systems—Unison uses file modtimes for a quick first
pass to tell which files have definitely not changed; then, for each file that
might have changed, it computes a fingerprint of the file's contents and
compares it against the last-synchronized contents. Also, the -times option
allows you to synchronize file times, but it does not cause identical files to
be changed; Unison will only modify the file times.)
</code></pre>

<p>So calling unison at either end will sync the files right.</p>

<h2 id="sync-between-more-than-machines">Sync Between More than Machines</h2>

<p>The built-in doc of <code>unison</code>, which is available via <code>unison -doc tutorial</code>,
has a section discussing how <code>unison</code> could be used to sync between more than
machines.</p>

<p>Using Unison to Synchronize More Than Two Machines</p>

<pre><code>Unison is designed for synchronizing pairs of replicas. However, it is
possible to use it to keep larger groups of machines in sync by
performing multiple pairwise synchronizations.

If you need to do this, the most reliable way to set things up is to
organize the machines into a “star topology,” with one machine
designated as the “hub” and the rest as “spokes,” and with each spoke
machine synchronizing only with the hub. The big advantage of the star
topology is that it eliminates the possibility of confusing “spurious
conflicts” arising from the fact that a separate archive is maintained
by Unison for every pair of hosts that it synchronizes.
</code></pre>

<p>I did not get what does it mean in the first reading. After that, I guess the
method it suggests is to establish a pair-wise sync among machines with certain
topology, which is to say: one needs to set up multiple profiles; each profile
sync between two machines; those machines form a topology so there is a hub
that will have a centralized sync state among all machines if you sync in the
right order.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Note on Installing Ubuntu on Newer Machines]]></title>
    <link href="http://shawnLeeZX.github.io/blog/2016/03/08/note-on-installing-ubuntu-on-newer-machines/"/>
    <updated>2016-03-08T13:48:00+08:00</updated>
    <id>http://shawnLeeZX.github.io/blog/2016/03/08/note-on-installing-ubuntu-on-newer-machines</id>
    <content type="html"><![CDATA[<p>This is the note supposed to note something peculiar things I met during
setting up Ubuntu on a newer machine, which is to say, with UEFI replacing
BIOS, GPT replacing MBR, Display Port and HDMI replacing VGA and DVI, and with
several GPUs.</p>

<p>Due to time reason, I fell back to my old way of installing Ubuntu, and have
not figured out what is the right way to install the newer machine mentioned
above, but the note is to note down possible guess, and the things have been
figured out, so I may have a thread to follow next time.</p>

<!-- more -->

<p>At the time I entered what was called BIOS of the machine, which is called
UEFI(Unified Extensible Firmware Interface), I was amazed that it was an almost
desktop GUI. The official lab machine of mine has a similar firmware, but since
I was not supposed to have access to it, I did not play with it much. I think
my most recent laptop should have also used UEFI, but I did not have any memory
what it is like, I guess I did not need to change things so I did not enter it.</p>

<h2 id="gpu-control-from-boot-to-os">GPU Control From Boot to OS</h2>

<p>The first thing I tried to figure out is how a GPU could be installed
properly. In other words, how could a GPU inserted in a socket could be
detected by the motherboard, then OS?</p>

<p>Normally a PC motherboard has an integrated card, and an optional discrete
graphical unit could be installed GPU card through PCIE sockets. There is a
switch in the UEFI to tell the motherboard where to look for a graphical
unit. Also, even if the GPU is not powered up, I could have a hint on the
monitor to tell me to what happened. So I think a GPU has a basic function unit
that offers motherboard basic graphical function so it could be used till the
machine boots into an OS.</p>

<p>The first problem I have met is there was no output when I connect DVI adapter
of the monitor to a TITAN Black that was inserted in the latter socket of the
motherboard, and could only get output when I connect the adapter to the GPU
inserted in the first PCIE socket. The GPU is not a TITAN Black but a 760.</p>

<p>There are two guesses why this situations happen. The first is UEFI only detect
GPU at the first PCIE socket and ignores all the remaining. This is reasonable
since no one is supposed to use multiple GPUs during boot time. But it seems I
have tried put a TITAN Black at the first socket, though I cannot clearly
remember it. So another guess is my current UEFI does not support TITAN at boot
time.</p>

<p>After the UEFI transfer the control to OS, the drivers in UEFI should not
function anymore. So drivers need to be installed in the OS.</p>

<p>The open source NVIDIA card driver, Nouveau, will be installed when installing
Ubuntu. I thought only when a NVIDIA GPU is physically inserted, its open
source driver would be installed. However, it seems the open source driver will
be installed even without a card. Maybe it is because in this case, a GPU card
could be used right after installation without re-installing kernel modules.</p>

<p>Nouveau has to be removed if I want to install the newest driver from NVIDIA
through the <code>*run</code> file, otherwise they would conflict. To do this, a file
needs to be added to <code>/etc/modprobe.d/</code> with the following contents.</p>

<p><code>
# generated by nvidia-installer
blacklist nouveau
options nouveau modeset=0
</code></p>

<p>It is actually generated by the <code>*run</code> file. I think it tells kernel not to
load nouveau module.</p>

<p>Then regenerate your kernel</p>

<p><code>
update-initramfs -u
</code></p>

<p>To completely wipe out <code>nouveau</code> — though I think even without doing it, it
would work, run the following command</p>

<p><code>
sudo apt-get remove xserver-xorg-video-nouveau
</code></p>

<p>To run <code>*run</code> file, one needs to log into a text console. A way I could find
that is commonly suggested on the web is to switch to one virtual terminal by
`Ctrl+Alt+F1’, then stop the X service</p>

<p><code>
sudo stop lightdm   or
sudo lightdm stop
</code></p>

<p>It did not work for me. So I need to reboot into text mode by editing
grub. More concretely, when the grub menu pops up, press <code>e</code> on the item, and
find <code>splash quiet</code>, and change it to <code>text</code>, then press <code>F10</code> to boot using
current edited entry.</p>

<p>One last thing before running the <code>*run</code> file. The <code>*run</code> file will build GPU
driver to kernel, but only once. So if your OS gets upgraded, you won’t be able
to log in desktop again. To work get around this, we need to install <code>dkms</code>, so
each time the kernel gets upgraded, all modules already built will be
automatically built again into the kernel.</p>

<p><code>
sudo apt-get install dkms
</code></p>

<p>All are settled, just run the <code>*run</code> file to install the driver.</p>

<p>To see what modules has been managed by <code>dkms</code>, use <code>dkms status</code>.</p>

<p>One last thing that tricked me up is to tell motherboard to use discrete
graphical unit after the driver has been installed. Otherwise, I could still
make it till the GUI login page, but after I have input my password, the screen
just flash a little, and ask me to log in again. I guess the problem is
since motherboard is configured to use integrated graphical unit, so the
discrete one is actually inactive, when <code>xorg.conf' tells </code>X11` to use the
discrete graphical unit, nothing is there. The solution is just to fall back.</p>

<p>I also have some guess on how <code>X11</code> make use of multiple GPUs. I have two
versions of <code>xorg.conf</code>, one from my official lab machine, and one from the one
I am setting up.</p>

<p>The official one</p>

<p>```
Section “Device”
    Identifier     “Device0”
    Driver         “nvidia”
    VendorName     “NVIDIA Corporation”
    BoardName      “GeForce GTX TITAN Black”
EndSection</p>

<p>Section “Device”
    Identifier     “Device1”
    Driver         “nvidia”
    VendorName     “NVIDIA Corporation”
    BoardName      “GeForce GTX TITAN Black”
    BusID          “PCI:1:0:0”
    Screen          1
EndSection
```</p>

<p>The other one is just</p>

<p><code>
Section "Device"
    Identifier     "Device0"
    Driver         "nvidia"
    VendorName     "NVIDIA Corporation"
EndSection
</code></p>

<p>The first one is generated by <code>nvidia-settings', the second one is generated by
</code>*run` file. I have three TITAN Black installed on the motherboard with the
second configuration file, and they are all functional.</p>

<p>The guess now is if no bus id is specified in <code>xorg.conf</code>, <code>X11</code> could pick any
one, and prefer to the one with lowest PCI id or GPU id.</p>

<p>A side note. To get the bus id of a card, use <code>lspci</code>, which output corresponds
to GPU is</p>

<p><code>
01:00.0 VGA compatible controller: NVIDIA Corporation GK110B [GeForce GTX TITAN Black] (rev a1)
</code></p>

<p><code>01:00.0</code> is the bus id, though I am still now know why the period becomes a colon.</p>

<h2 id="note-on-cuda">Note On CUDA</h2>

<p>After all those efforts to install NVIDIA driver through <code>*run</code> file, I found
<code>cuda</code> installation(using the network deb provided by NVIDIA) just overrided
the driver I have just installed…</p>

<p>I am not sure whether dkms will be automatically installed, or nouveau be
automatically blacklisted, though the installation of cuda does not mention it,
which is to mean they probably will take care of this. If this is so the
installation of NVIDIA driver and CUDA will be much easier.</p>

<p>I notice the <code>xorg.conf</code> is not changed after the ``new’’ driver being
installed.</p>

<h2 id="bios-mode-or-uefi-mode-ubuntu">BIOS mode or UEFI mode Ubuntu</h2>

<p>The last set of note is about installing Ubuntu in BIOS mode or UEFI mode,
which corresponds to using MBR or GPT partition table, and may be some other
difference.</p>

<p>At the time when choosing the boot media, even if your USB only has one Ubuntu
on it, the boot menu would show up as entries, one for normal BIOS mode
ubuntu(which is just named Ubuntu), one for UEFI mode(which has a UEFI in the
name). I have not tried the second one. The UEFI is a pretty new thing to me,
since the last time I learned something about it, UEFI is still in its
infancy.</p>

<p>If UEFI is chosen, the partition table of the hard disk where the boot loader
would be installed must be GPT, which is written in the new standard. The boot
loader of MBR and GPT are different(obviously). For GPT, an explicitly
formatted and allocated partition seems to be needed(not verified). As for MBR,
as everyone knows, the space for the boot loader will always be left out. Also,
to boot from a GPT partitioned disk, a boot flag need to be marked on the disk,
otherwise, OS won’t boot. There are still many other difference I have not
figured out yet.</p>

<h2 id="reference">Reference</h2>

<ol>
  <li><a href="http://www.linuxsecrets.com/blog/15questions-troubleshooting/2015/09/10/1651-how-to-remove-nouveau-and-install-nvidia-drivers">How to Remove Nouveau and Install Nvidia Drivers</a></li>
</ol>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[VLC下使用中文字幕]]></title>
    <link href="http://shawnLeeZX.github.io/blog/2016/02/16/vlcxia-shi-yong-zhong-wen-zi-mu/"/>
    <updated>2016-02-16T22:00:00+08:00</updated>
    <id>http://shawnLeeZX.github.io/blog/2016/02/16/vlcxia-shi-yong-zhong-wen-zi-mu</id>
    <content type="html"><![CDATA[<p>记如何在VLC下使用中文字幕。</p>

<!-- more -->

<p>默认状态下，VLC会遇到两个问题，一是解码的codecs所用不对，而是用于显示字体的渲染
器(render)所用字体不对。</p>

<p>第一个问题的解决办法一是更改VLC所用的codecs；二是修改文件的codecs为utf-8。第一
种方法在<a href="http://bbs.feng.com/read-htm-tid-344593.html">这里</a>有介绍。第二种方法
我发现Vim可以完美完成，特此记之。</p>

<p>用Vim打开字幕文件，然后使用如下命令：</p>

<p><code>
:set fileencoding=utf-8
</code></p>

<p>保存，退出。</p>

<p>第二个问题的解决也来自之上的
<a href="http://bbs.feng.com/read-htm-tid-344593.html">链接</a>。为防止链接失效，特此重述
方法：</p>

<p>打开VLC的<code>Preferences</code>窗口（<code>Ctrl+P</code>），点击右下角的<code>all</code>，在左边的索引中依次选择
<code>Video -&gt; Subtitles/OSD -&gt; Text renderer</code>，右边的设置区第一项为<code>Font</code>，点击<code>Browse</code>按
钮选择一项中文字体，如<code>WenQuanYi Micro Hei</code>。更改完成之后需要重启VLC。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Note on Running Tensorflow in Anaconda]]></title>
    <link href="http://shawnLeeZX.github.io/blog/2016/01/09/note-on-running-tensorflow-in-anaconda/"/>
    <updated>2016-01-09T19:25:00+08:00</updated>
    <id>http://shawnLeeZX.github.io/blog/2016/01/09/note-on-running-tensorflow-in-anaconda</id>
    <content type="html"><![CDATA[<p>Due to conflict of protobuf version, I have to run tensorflow in a sandbox
environment, aka anaconda. This is the note to note down some of its tricky
parts I spent some time figuring out.</p>

<!-- more -->

<p>Most of the packages are backward compatible, so normal packages could be
installed on servers normally, by <a href="http://www.ansible">Ansible</a>. But if
Caffe(it seems the newest Caffe upgraded to protobuf3) and tensorflow want to
be installed in the same machine, protobuf2 and protobuf3 have to co-exist. Due
to their
<a href="https://www.tensorflow.org/versions/master/get_started/os_setup.html#mac-os-x-typeerror-init-got-an-unexpected-keyword-argument-syntax">conflict</a>,
they cannot co-exist. So to not break others environment, I have to install
tensorflow in anaconda.</p>

<p>There are two things I think I may need in the future:</p>

<ol>
  <li>To install Anaconda and all consequent python packages in it using Ansible.</li>
  <li>A bug either in pip or in conda that needs some workaround.</li>
</ol>

<h2 id="using-ansible-with-anaconda">Using Ansible with Anaconda</h2>

<p>Conda has a <a href="http://conda.pydata.org/docs/help/silent.html">silent mode</a>, so it
could be install using shell script, which could be achieved using the <code>shell</code>
module in Ansible.</p>

<p>To install consequent packages all in Anaconda environment, we could write a
playbook that has the location of <code>pip</code> as a variable, so by passing different
<code>pip</code> binary, we could install the python packages wherever we want.</p>

<h2 id="solve-cannot-remove-entries-from-nonexistent-file--easy-installpth">Solve ``Cannot remove entries from nonexistent file: … easy-install.pth’’</h2>

<p>There is a bug preventing one upgrading packages in Anaconda. Where this bug
belongs to pip/setuptools or conda seems still in
<a href="https://github.com/pypa/pip/issues/2751">consideration</a>.</p>

<p>The workaround I used, one of the workarounds suggested by the above link,
which I think is the simplest one is to add <code>--ignore-installed</code> option to
<code>pip</code>.</p>

<p>If your packages in contained in <code>conda</code>’s collection, the best solution is to
install it there. For instance, for <code>numpy</code>, it is just better to install by</p>

<p><code>bash
conda update numpy
</code></p>
]]></content>
  </entry>
  
</feed>
