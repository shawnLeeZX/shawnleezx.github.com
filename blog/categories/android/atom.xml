<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android | SHAWN LEE]]></title>
  <link href="http://shawnLeeZX.github.io/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://shawnLeeZX.github.io/"/>
  <updated>2015-07-02T15:02:39+08:00</updated>
  <id>http://shawnLeeZX.github.io/</id>
  <author>
    <name><![CDATA[Shawn]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Android Beginner's Summary]]></title>
    <link href="http://shawnLeeZX.github.io/blog/2014/04/12/android-beginners-summary/"/>
    <updated>2014-04-12T22:11:00+08:00</updated>
    <id>http://shawnLeeZX.github.io/blog/2014/04/12/android-beginners-summary</id>
    <content type="html"><![CDATA[<p>It seems that the most popular books teaching about android on
Amazon(<em>Professional Android 4 Application Development</em> &amp; <em>Android Programming
The Big Nerd Ranch Guide</em>) do not cover an integrate part about manifest, and
some important tags, such as application and activity. Plus reading one more
book(<em>Beginning Android Games</em>), I will try to summary the knowledge that is
relevant to code nontrivial android programs.</p>

<!-- more -->

<h2 id="manifest">Manifest</h2>

<p>An Android application can consist of a multitude of different components:</p>

<ul>
  <li><strong>Activities</strong>: These are user-facing components that present a UI to interact
with.</li>
  <li><strong>Services</strong>: These are processes that work in the background and don’t
have a visible UI. A service might be responsible for polling a mail server
for new e-mails, for example. Content providers: These components make parts
of your application data available to other applications.</li>
  <li><strong>Intents</strong>: These are messages created by the system or applications themselves,
that are then passed on to any interested party. Intents might notify us of
system events such as the SD card being removed or the USB cable being
connected. Intents are also used by the system for starting components of our
application, such as activities. We can also fire our own intents to ask
other applications to perform an action, such as opening a photo gallery to
display an image or starting the Camera application to take a photo.</li>
  <li><strong>Broadcast receivers</strong>: These react to specific intents, and might execute an
action such as starting a specific activity or sending out another intent to
the system.</li>
</ul>

<p>An Android application has no single point of entry, as we are used to having
on a desktop operating system (e.g., in the form of Java’s main() method).
Instead, components of an Android application are started up or asked to
perform a certain action by specific intents.</p>

<p>What components our application is composed of and which intents these
components react to are defined in the application’s manifest file. The Android
system uses this manifest file to get to know what our application is made of,
such as the default activity to display when the application is started.</p>

<p>Above is the role manifest file plays in the overall android system, besides
that, in more fine granuity, manifest provides information about this app, for
instance, package name, minimum sdk version, installation locatoin, etc.. You
can find more attributes of manifest <a href="http://developer.android.com/guide/topics/manifest/manifest-intro.html">here</a>.</p>

<h2 id="android-xml-schema">Android Xml Schema</h2>

<p>This should not be an android programming knowledge. But since at least I did
not have much knowledge about xml beforehand, I will note this down in case
there are a bunch of people like me.</p>

<p>At each manifest and layout xml files, there must be one line that likes the
first line of the snippet below.</p>

<p><code>xml
&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android"
      package               = "com.venn.app"
      android:versionCode   = "1"
      android:versionName   = "1.0"&gt;
</code></p>

<p>Basically, this line defines schema for meaningful tags in this xml file. One
well-known example is HTML, which is one type of xml defined specifically for
web browsering.</p>

<p>What’s more, this line also defines a namespace for this xml file, which is
android(the word after the colon) in this case.</p>

<p>An XML schema is a description of a type of XML document, typically expressed
in terms of constraints on the structure and content of documents of that type,
above and beyond the basic syntactical constraints imposed by XML itself. These
constraints are generally expressed using some combination of grammatical rules
governing the order of elements, Boolean predicates that the content must
satisfy, data types governing the content of elements and attributes, and more
specialized rules such as uniqueness and referential integrity constraints.[2]</p>

<p>See how more details about namespace <a href="http://www.w3schools.com/xml/xml_namespaces.asp">here</a>.</p>

<h2 id="how-android-find-the-main-entry-of-one-application">How Android Find the Main Entry of One Application</h2>

<p>This example and some of explanation come from the book[1].</p>

<p>To let android know what is your program’s entry, you must define one activity
that defined an attribute called <code>intent-filter</code> – this is how it works, like
the following xml snippet.</p>

<p>```xml
<activity android:name=".MrNomActivity" android:label="Mr. Nom" android:screenorientation="portrait">
    android:configChanges="keyboard|keyboardHidden|orientation"&gt;</activity></p>

<pre><code>&lt;intent-filter&gt;
    &lt;action android:name="android.intent.action.MAIN" /&gt;
    &lt;category android:name="android.intent.category.LAUNCHER" /&gt;
&lt;/intent-filter&gt;
</code></pre>
<p>&lt;/activity&gt;
```</p>

<p>As I pointed out earlier, there’s no notion of a single main entry point to
your application on Android. Instead, we can have multiple entry points in the
form of activities and services that are started due to specific intents being
sent out by the system or a third- party application. Somehow we need to
communicate to Android which activities and services of our application will
react (and in what ways) to specific intents. That’s where the <intent-filter>
element comes into play.</intent-filter></p>

<p>In the preceding example, we specify two types of intent filters: an <action>
and a <category>. The <action> element tells Android that our activity is a
main entry point to our application. The <category> element specifies that we
want that activity to be added to the application launcher. Both elements
together allow Android to infer that when the icon in the application launcher
for the application is pressed, it should start that specific activity.</category></action></category></action></p>

<p>For both the <action> and <category> elements, all that gets specified is the
name attribute, which identifies the intent the activity will react to. The
intent android.intent.action.MAIN is a special intent that the Android system
uses to start the main activity of an application. The intent
android.intent.category.LAUNCHER is used to tell Android whether a specific
activity of an application should have an entry in the application launcher.</category></action></p>

<p>Usually we’ll only have one activity that specifies these two intent filters.</p>

<h2 id="relevant-attributes-explained">Relevant Attributes Explained</h2>

<p>There are some commmon attributes that exist in various android tags. I will
list some that once cause confusion to me.</p>

<p>Take activity as an example. This example and some of the explanation come from
the book[1].</p>

<p>```xml
<activity android:name=".MrNomActivity" android:label="Mr. Nom" android:screenorientation="portrait">
    android:configChanges="keyboard|keyboardHidden|orientation"&gt;</activity></p>

<pre><code>&lt;intent-filter&gt;
    &lt;action android:name="android.intent.action.MAIN" /&gt;
    &lt;category android:name="android.intent.category.LAUNCHER" /&gt;
&lt;/intent-filter&gt;
</code></pre>
<p>&lt;/activity&gt;
```</p>

<p>For each attribute, there is a <code>android:</code> appended at the beginning. This is
how you use namespace in xml(Remember the namespace metioned before?).</p>

<ul>
  <li>name: This specifies the name of the activity’s class relative to the package
attribute we specified in the <manifest> element. You can also specify a
fully qualified class name here.</manifest></li>
  <li>label: We already specified the same attribute in the <code>&lt;application&gt;</code>. This
label is displayed in the title bar of the activity (if it has one).The label
will also be used as the text displayed in the application launcher if the
activity we define is an entry point to our application. If we don’t specify
it, the label from the <application> element will be used instead. Note that
I used a raw string here instead of a reference to a string in the string.xml
file.</application></li>
</ul>

<p>However, there is also one attribute called <code>id</code>, which is used a lot when you
are referencing resources. I was wondering what is the difference between the
<code>name</code> and <code>id</code>, since they both used to reference things.</p>

<p>For now, based on my understanding, <code>name</code> is used to references things like
class name(see above snippet), constant(see the line below. I think permission
is just a contant defined.), which is part of the code. While <code>id</code> is used to
reference instances of <code>name</code>. You need an id to reference the external
resources, like string, image, icon to let android know what you want to use.</p>

<p>You can find documentation about external resources of android <a href="http://developer.android.com/guide/topics/resources/available-resources.html">here</a>.</p>

<p><code>xml
&lt;uses-permission android:name = "android.permission.BLUETOOTH" /&gt;
</code></p>

<p>For example, in this snippet below, which defines a fragment to be used. It has
both <code>name</code> and <code>id</code> attributes. The <code>name</code> attribute contains the information
what class is used to instantiate this fragment, while <code>id</code> contains the
information to let program find this fragment after creation.</p>

<p><code>xml
&lt;fragment android:name="com.example.android.fragments.HeadlinesFragment"
              android:id="@+id/headlines_fragment"
              android:layout_weight="1"
              android:layout_width="0dp"
              android:layout_height="match_parent" /&gt;
</code></p>

<ul>
  <li>[1] Beginning Android Games</li>
  <li>[2] http://en.wikipedia.org/wiki/XML_schema</li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Use adb with multiple avd and physical devices]]></title>
    <link href="http://shawnLeeZX.github.io/blog/2014/03/09/use-adb-with-multiple-avd-and-physical-devices/"/>
    <updated>2014-03-09T00:12:00+08:00</updated>
    <id>http://shawnLeeZX.github.io/blog/2014/03/09/use-adb-with-multiple-avd-and-physical-devices</id>
    <content type="html"><![CDATA[<p>In real world programming practice, you will probably use one virtual device
for small testing and one physical device for larger testing or installation,
maybe even more devices. It would be annoy to shut down one of them to get
things done.</p>

<!-- more -->

<p>To let adb select the device to perform action, <code>-e</code>, <code>-d</code> and <code>-s</code> flags
should be used.</p>

<p>If you only have two devices, one virtual and one physical, to select only the
virtual one to install apk, use the following command:</p>

<p><code>java
adb -e install NAME.apk
</code></p>

<p>To select the physical one, use the following command:</p>

<p><code>java
adb -d install NAME.apk
</code>
But what if you have multiple devices? <code>-s</code> flag should be used.</p>

<p>First, use <code>adb devices</code> to see the serial number of each devices, then use the
following command:</p>

<p><code>java
adb -s SERIAL_NUMBER_OF_THE_DEVICE install NAME.apk
</code></p>

<p>Hope that helps.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Code Android Program in Command Line]]></title>
    <link href="http://shawnLeeZX.github.io/blog/2014/02/21/code-android-program-in-command-line/"/>
    <updated>2014-02-21T00:24:00+08:00</updated>
    <id>http://shawnLeeZX.github.io/blog/2014/02/21/code-android-program-in-command-line</id>
    <content type="html"><![CDATA[<p>I do not like GUI when coding…</p>

<p>This post will talk about how to write android program using pure command line.</p>

<!-- more -->

<p>I will skip the installation part…since I installed it a long time ago…</p>

<h2 id="create-and-compile-project">Create and compile project</h2>

<p>First add binaries into bash <code>PATH</code>:</p>

<p><code>bash
export PATH="$HOME/mine/software/android-sdk-linux/platform-tools/:$PATH"
export PATH="$HOME/mine/software/android-sdk-linux/tools/:$PATH"
</code></p>

<p>To create a project:</p>

<p><code>bash
android create project --target 1 --name MyFirstApp --path ./MyFirstApp --activity MainActivity --package com.example.myfirstapp
</code></p>

<p>To compile the project, <code>cd</code> to the root of the project, then type:</p>

<p><code>bash
ant debug
</code></p>

<h2 id="preparation-for-using-physical-android-device">Preparation for using physical android device</h2>

<p>You can use a emulator provided by from sdk, however, my laptop is too slow to
use a emulator, thus I have to use a physical device to do this.</p>

<p>In linux, one thing a user should and will understand eventually is privilege.
To make adb have access to your device, some work should be done beforehand.</p>

<p>On the official android developer site, detailed <a href="http://developer.android.com/tools/device.html#setting-up">solution</a> has been provided.</p>

<p>Here, I will briefly talk about what should and why it should be done.</p>

<p>From linux kernels 2.6 and beyond, a user space solution has been provided for
a dynamic <code>/dev</code> directory, which is udev.</p>

<p>The following two paragraphs comes from the man page of udev.</p>

<p>udev supplies the system software with device events, manages
permissions of device nodes and may create additional symlinks in
the /dev directory, or renames network interfaces. The kernel
usually just assigns unpredictable device names based on the
order of discovery. Meaningful symlinks or network device names
provide a way to reliably identify devices based on their
properties or current configuration.</p>

<p>The udev daemon, udevd(8), receives device uevents directly from
the kernel whenever a device is added or removed from the system,
or it changes its state. When udev receives a device event, it
matches its configured set of rules against various device
attributes to identify the device. Rules that match may provide
additional device information to be stored in the udev database
or to be used to create meaningful symlink names.</p>

<p>The user created rules to be matched by udev is located at
<code>/etc/udev/rules.d/</code>.</p>

<p>To make your android devices can be recognized without have root privilege,
create a file named <code>51-android.rules</code> with the following contents:</p>

<p><code>bash
SUBSYSTEM=="usb", ATTR{idVendor}=="0bb4", MODE="0666", GROUP="plugdev" 
</code></p>

<p><code>idVendor</code> should be the id of the vendor of your device, which can be gotten
using <code>lsusb</code> command.</p>

<p>After changing the rules, restart udev service:</p>

<p><code>bash
sudo service udev restart
</code></p>

<p>And if you are not in the <code>plugdev</code> group, add you in:</p>

<p><code>bash
sudo adduser USER_NAME plugdev
</code></p>

<p>Note that you have to logout and login to make the <code>/etc/group</code> file to be
reloaded.</p>

<p>If all work well, you can check your device using:</p>

<p><code>bash
adb devices
</code></p>

<p>Sometimes, a reboot is needed to get adb detect your device. I do not know why.</p>

<p>Again, note that some devices may not have a serial number, like my huawei
smartphone, thus adb will only show a sequence of question mark. This is fine.</p>

<p>As long as you can log on your device Using <code>adb shell</code>, you will be able to
install apk package onto your smartphone.</p>

<h2 id="install-your-android-program">Install your android program</h2>

<p>Now, you can install your android program:</p>

<p><code>bash
adb install bin/PROGRAM_NAME.apk
</code></p>

<p>WALA! your program is on the physical phone already!</p>

<h2 id="run-program-in-emulator">Run program in emulator</h2>
<p>It would be better if you just have an emulator to test some minor change while
only testing big change on physical device.</p>

<p>The procedure is friendly as well. Android SDK provides a GUI for this. Type:</p>

<p><code>bash
android avd
</code></p>

<p>This will bring up the GUI. Go with your intuition or search for the tutorial
given by android.</p>

<p>The reason I wrote this down is to note down this: when you have multiple
device connected, both emulators and physical devices. <code>-e</code> option means the
command is meant for emulators while <code>-d</code> for physical devices.</p>

<p>For example, this will install apk package on emulator:</p>

<p><code>bash
adb -e install NAME.apk
</code></p>

<p>while this will install apk package on physical device:</p>

<p><code>bash
adb -d install NAME.apk
</code></p>

<p>If there are multiple emulators or physical devices, try <code>-s</code> flag.</p>
]]></content>
  </entry>
  
</feed>
