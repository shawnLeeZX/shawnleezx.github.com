<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ansible | SHAWN LEE]]></title>
  <link href="http://shawnLeeZX.github.io/blog/categories/ansible/atom.xml" rel="self"/>
  <link href="http://shawnLeeZX.github.io/"/>
  <updated>2016-01-05T12:03:41+08:00</updated>
  <id>http://shawnLeeZX.github.io/</id>
  <author>
    <name><![CDATA[Shawn]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ansible Variables Explained]]></title>
    <link href="http://shawnLeeZX.github.io/blog/2014/04/08/ansible-variables-explained/"/>
    <updated>2014-04-08T20:10:00+08:00</updated>
    <id>http://shawnLeeZX.github.io/blog/2014/04/08/ansible-variables-explained</id>
    <content type="html"><![CDATA[<p>The variables mechanism provided by ansible is great, however, not well
documented. It takes me hours to understand different types of variables of
ansible.</p>

<p>I will describe it in a logical sequence when writing or using ansible
playbook. I assume the root folder of your ansible playbooks is under
<code>/etc/ansible/</code>.</p>

<p><em>NOTE: the examples are taken from ansible documentation.</em></p>

<!-- more -->

<p>I will skip describing why we need variables … You should be knowledgable
about why…</p>

<h2 id="host-variables">Host Variables</h2>

<p>First, there will be host specifical need, you can define those variables in
two ways. </p>

<h3 id="ad-hoc-way">Ad hoc Way</h3>

<p>The first is to define them in the inventory files, like the following:</p>

<p><code>bash
[atlanta]
host1 http_port=80 maxRequestsPerChild=808
host2 http_port=303 maxRequestsPerChild=909
</code></p>

<h3 id="ansible-best-practice">Ansible Best Practice</h3>

<p>To better maintain your playbooks, it would be better you define your host
specifical variables seperated from inventory file. Ansible provides mechanism
to let you define variables in <code>host_vars</code> folder. For example:</p>

<h2 id="bash">```bash</h2>
<p># file: /etc/ansible/host_vars/xyz.boston.example.com
ntp_server: override.example.com
```</p>

<h2 id="group-variables">Group Variables</h2>

<p>Second, beyond host specifical variables, there is group variables. Similarly,
there is also two ways to define group variables.</p>

<h3 id="ad-hoc-way-1">Ad hoc Way</h3>

<p>The first is to define them in the inventory files, like the following:</p>

<p>```bash
[atlanta]
host1
host2</p>

<p>[atlanta:vars]
ntp_server=ntp.atlanta.example.com
proxy=proxy.atlanta.example.com
```
In the above example, lines under the <code>[altanta:vars]</code> define variables of
group <code>atlanta</code>.</p>

<h3 id="best-practice">Best Practice</h3>

<p>Similarly, for ansible best practice, you should define group specifical files
in <code>host_vars</code> file. For example, you can define variables for group <code>raleigh</code>
in file <code>/etc/ansible/group_vars/raleigh</code>, using the following lines:</p>

<h2 id="yaml">```yaml</h2>
<p>ntp_server: acme.example.org
database_server: storage.example.org
```</p>

<h2 id="some-built-in-variables-provided-by-ansible">Some Built-in Variables Provided by Ansible</h2>

<p><code>bash
ansible_ssh_host
  The name of the host to connect to, if different from the alias you wish to give to it.
ansible_ssh_port
  The ssh port number, if not 22
ansible_ssh_user
  The default ssh user name to use.
ansible_ssh_pass
  The ssh password to use (this is insecure, we strongly recommend using --ask-pass or SSH keys)
ansible_sudo_pass
  The sudo password to use (this is insecure, we strongly recommend using --ask-sudo-pass)
ansible_connection
  Connection type of the host. Candidates are local, ssh or paramiko.  The default is paramiko before Ansible 1.2, and 'smart' afterwards which detects whether usage of 'ssh' would be feasible based on whether ControlPersist is supported.
ansible_ssh_private_key_file
  Private key file used by ssh.  Useful if using multiple keys and you don't want to use SSH agent.
ansible_python_interpreter
  The target host python path. This is useful for systems with more
  than one Python or not located at "/usr/bin/python" such as \*BSD, or where /usr/bin/python
  is not a 2.X series Python.  We do not use the "/usr/bin/env" mechanism as that requires the remote user's
  path to be set right and also assumes the "python" executable is named python, where the executable might
  be named something like "python26".
ansible\_\*\_interpreter
  Works for anything such as ruby or perl and works just like ansible_python_interpreter.
  This replaces shebang of modules which will run on that host.
</code></p>

<h2 id="facts">Facts</h2>

<p>There is another type of variables called fact, which is built-in and used to
store information discovered while probing remote hosts. More details can be
found <a href="http://docs.ansible.com/playbooks_variables.html#id25">here</a>.</p>

<h2 id="playbook-variables">Playbook Variables</h2>

<p>Variables defined in <code>host_vars</code> and <code>group_vars</code> are actually attributes of
hosts and groups. There is also need to define variables in playbook, which
normally is used for operation. Again, there are also two ways to define
ansible playbook specifical variables.</p>

<p>From now on, examples are taken from
<a href="https://github.com/phred/ansible-examples/blob/master/pedantically_commented_playbook.yml">pedantically_commented_playbook</a>.</p>

<h3 id="ad-hoc-way-2">Ad hoc Way</h3>

<p>The first is to define using <code>var</code> attribute. For example:</p>

<p>```yaml
###########
# Playbook attribute: vars
# Default: none
# Required: no
# Description:
#  Set configuration variables passed to templates &amp; included playbooks
#  and handlers.  See below for examples.
vars:
color: brown</p>

<p>web:
  memcache: 192.168.1.2
  httpd: apache
# Tree-like structures work as expected, but be careful to surround
#  the variable name with ${} when using.
#
# For this example, ${web.memcache} and ${web.apache} are both usable
#  variables.</p>

<h6 id="section">#</h6>
<p># The following works in Ansible 0.5 and later, and will set $config_path
# “/etc/ntpd.conf” as expected.
#
# In older versions, $config_path will be set to the string “/etc/$config”
#
config: ntpd.conf
config_path: /etc/$config</p>

<h6 id="section-1">#</h6>
<p># Variables can be set conditionally. This is actually a tiny snippet
# of Python that will get filled in and evaluated during playbook execution.
# This expressioun should always evaluate to True or False.
#
# In this playbook, this will always evaluate to False, because ‘color’
#  is set to ‘brown’ above.
#
# When ansible interprets the following, it will first expand $color to
# ‘brown’ and then evaluate ‘brown’ == ‘blue’ as a Python expression.
is_color_blue: “‘$color’ == ‘blue’”</p>

<h4 id="section-2">#</h4>
<p># Builtin Variables
#
# Everything that the ‘setup’ module provides can be used in the
# vars section.  Ansible native, Facter, and Ohai facts can all be
# used.
#
# Run the setup module to see what else you can use:
# ansible -m setup -i /path/to/hosts.ini host1
main_vhost: ${ansible_fqdn}
public_ip:  ${ansible_eth0.ipv4.address}</p>

<h1 id="varsfiles-is-better-suited-for-distro-specific-settings-however">vars_files is better suited for distro-specific settings, however…</h1>
<p>is_ubuntu: “’${ansible_distribution}’ == ‘ubuntu’”
```</p>

<h3 id="best-practice-1">Best Practice</h3>

<p>Second, you can use <code>vars_file</code> to organize your variables. This is extremely
useful when you are in need to provide different variables when concerning
dynamically determined information. For example:</p>

<p>```yaml
##########
# Playbook attribute: vars_files
# Required: no
# Description:
#   Specifies a list of YAML files to load variables from.
#
#   Always evaluated after the ‘vars’ section, no matter which section
#   occurs first in the playbook.  Examples are below.
#
#   Example YAML for a file to be included by vars_files:
#   —
#   monitored_by: phobos.mars.nasa.gov
#   fish_sticks: “good with custard”
#   # (END OF DOCUMENT)
#
#   A ‘vars’ YAML file represents a list of variables. Don’t use playbook
#   YAML for a ‘vars’ file.
#
#   Remove the indentation &amp; comments of course, the ‘—’ should be at
#   the left margin in the variables file.
#
vars_files:
# Include a file from this absolute path
- /srv/ansible/vars/vars_file.yml</p>

<h1 id="include-a-file-from-a-path-relative-to-this-playbook">Include a file from a path relative to this playbook</h1>
<ul>
  <li>vars/vars_file.yml</li>
</ul>

<h1 id="by-the-way-variables-set-in-vars-are-available-here">By the way, variables set in ‘vars’ are available here.</h1>
<ul>
  <li>vars/$hostname.yml</li>
</ul>

<h1 id="its-also-possible-to-pass-an-array-of-files-in-which-case">It’s also possible to pass an array of files, in which case</h1>
<p># Ansible will loop over the array and include the first file that
# exists.  If none exist, ansible-playbook will halt with an error.
#
# An excellent way to handle platform-specific differences.
- [ vars/$platform.yml, vars/default.yml ]</p>

<h1 id="files-in-varsfiles-process-in-order-so-later-files-can">Files in vars_files process in order, so later files can</h1>
<p># provide more specific configuration:
- [ vars/$host.yml ]</p>

<h1 id="hey-but-if-youre-doing-host-specific-variable-files-you-might">Hey, but if you’re doing host-specific variable files, you might</h1>
<p># consider setting the variable for a group in your hosts.ini and
# adding your host to that group. Just a thought.
```</p>

<h2 id="passing-variables-on-the-command-line">Passing Variables On The Command Line</h2>

<p>You are absolutely in need to switch from test machine to real deployment,
which means you need to change the host rather frequently. This is the case
where command line variables are useful.</p>

<p>For example, you need to change host name each time. To test, you use:</p>

<p><code>bash
ansible-playbook playbook.yml --extra-vars "hosts=local_machine"
</code></p>

<p>As for real deployment, you can use:</p>

<p><code>bash
ansible-playbook playbook.yml --extra-vars "hosts=servers"
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Setup Linux From Fresh Installation Using Ansible]]></title>
    <link href="http://shawnLeeZX.github.io/blog/2014/02/20/setup-linux-from-fresh-installation-using-ansible/"/>
    <updated>2014-02-20T00:19:00+08:00</updated>
    <id>http://shawnLeeZX.github.io/blog/2014/02/20/setup-linux-from-fresh-installation-using-ansible</id>
    <content type="html"><![CDATA[<p>Previously, I have wrote two posts about linux administration – the
<a href="/blog/2014/02/20/from-linux-user-to-administrator/">first</a> one talked about the jobs should be done on one machine, the
<a href="/blog/2014/02/20/linux-administration-beyond-one-machine/">second</a> one talked about how to setup ansible to control remote nodes.</p>

<p>This post talks about how to use ansible to make a customized ubuntu 12.04
desktop from fresh installation using ansible. However, setting up a server is
subset of setting up desktop machine, which has been mentioned in the second
<a href="/blog/2014/02/20/linux-administration-beyond-one-machine/">post</a>.</p>

<!-- more -->

<p>This post is caused by a misbehaved system backup image – the system backup
image is not working. I have to pay the debt now.</p>

<p>However, this time I am equipped with ansible, an apps and IT infrastructure
automation software. I plan to write a playbook to set up customized ubuntu
from scratch.</p>

<p>An important note about using this method to customze machine is you HAVE TO
HAVE A DECENT NETWORK CONNECTION to finish this in a short(meaning bearable)
time.</p>

<h2 id="a-note-about-virtualbox">A note about virtualbox</h2>

<p>For some reason, I have to use linux on virtualbox, this is how to mount shared
folder on the virtual ubuntu on virtual machine.</p>

<p><code>bash
sudo mount -t vboxsf NAME_OF_SHARED_FOLDER MOUNT_POINT
</code></p>

<p>However, if you choose <code>automount</code> and <code>make permenant</code> option when enabling
shared folder, you can find your shared folder here:
<code>/media/sf_SHARED_FOLDER_NAME</code>.</p>

<h2 id="preparation">Preparation</h2>

<p>Remove unnecessary folders created by ubuntu:</p>

<p><code>bash
cd
rmdir Downloads Music Public Videos Documents Templates
</code></p>

<p>To make the terminal works more efficiently, I install <code>tmux</code> beforehand and
config it as this <a href="/blog/2014/02/08/make-vim-style-tmux/">post</a>.</p>

<p><code>bash
sudo apt-get install tmux
</code></p>

<p>To use the more cutting-edge ansible, I install <code>git</code> beforehand.</p>

<p><code>bash
sudo apt-get install git
</code></p>

<h2 id="set-up-ansible">Set up ansible</h2>

<p>Then I clone the most recent version of <code>ansible</code>.</p>

<p><code>bash
git clone https://github.com/ansible/ansible
</code></p>

<p>Add the following line in <code>.bashrc</code> to source the <code>env-setup</code> script to make
ansible available in the <code>PATH</code>.</p>

<p><code>bash
source PATH_TO_ANSIBLE_FOLDER/hacking/env-setup
</code></p>

<p>Install dependences of ansible
<code>bash
sudo apt-get install python-pip
sudo pip install paramiko PyYAML jinja2 httplib2
</code>
## Run ansible locally</p>

<p>I will only talk about how to run ansible playbook locally.</p>

<p>The playbook is like this:</p>

<h2 id="yaml">```yaml</h2>

<ul>
  <li>
    <p>hosts: local_machine
connection: local
user: shawn
gather_facts: no
sudo: yes</p>

    <p>roles:
  - set_up_system
```</p>
  </li>
</ul>

<p><code>local_machine</code> is a group which only have <code>127.0.0.1</code> ip and 
<code>connection: local</code> tells ansible to run the playbook locally.</p>

<p>Remember to add the <code>-K</code> option when using <code>sudo: yes</code>.</p>

<p>The playbooks I wrote can be found <a href="https://github.com/hhiker/ansible_playbook_setup_machine">here</a>.</p>

<p><a name="desktopvim"></a>
## A note on compiling vim</p>

<p>There is one crucial feature of vim – multiple clipboards. However, this
feature is only available when linux have X11 environment, which means it does
not work on server.</p>

<p>Previously, I have wrote how to compile vim from source on a linux server. You
can find it
<a href="/blog/2014/02/20/from-linux-user-to-administrator/#compilevim">here</a>. To
compile vim on desktop with clipboard enabled, your os should have necessary
X11 libraries:</p>

<p><code>bash
sudo apt-get install xorg-dev
</code></p>

<p>This will work.</p>

<p>To check whether your the Makefile your have configured have X11 enabled or
not, try the following command:</p>

<p>```bash
egrep X11 src/auto/config.h</p>

<p>```
if the output is this, it means your have clipboard support.</p>

<p><code>c
#define HAVE_X11
</code></p>

<p>If the output is this, it means no clipboard support is available.
```c
/* #undef HAVE_11 */</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux Administration Beyond One Machine]]></title>
    <link href="http://shawnLeeZX.github.io/blog/2014/02/20/linux-administration-beyond-one-machine/"/>
    <updated>2014-02-20T00:15:00+08:00</updated>
    <id>http://shawnLeeZX.github.io/blog/2014/02/20/linux-administration-beyond-one-machine</id>
    <content type="html"><![CDATA[<p>Previously, I have written about the action taken on a single machine, which
script or command is suffice. However, if you want to do those things on a
dozens, hundreds even more machines, you have to use more advanced tools to
achieve that.</p>

<!-- more -->

<p>I am using ansible to do this.</p>

<p>The docs of ansible provides a detailed way to learn ansible. However, there
may be some problems ansible newbies like me will encounter which are only
mentioned briefly in the docs.</p>

<p>Note that this post is not about learning how to write ansible playbooks, but
noting down the problems I have encountered along the way learning using
ansible. Read the ansible documentation if you want to learn ansible.</p>

<p>You can find the playbook I wrote to setup my desktop pc <a href="https://github.com/hhiker/ansible_playbook_setup_machine">here</a>.</p>

<p>You can use the <code>setup_system_server_part</code> role to setup remote servers.</p>

<h2 id="use-password-to-ssh-on-for-the-first-time">Use password to ssh on for the first time</h2>

<p>Normaly, when you are using ansible to control remotes nodes for the first
time, you do not have your key installed in the <code>authorized_keys</code> on the nodes.
Thus you have to use password to ssh on. To achieve this, you need to add <code>-k</code>
option in the ansible command.</p>

<h2 id="disable-host-key-checking">Disable host key checking</h2>

<p>What’s more, from ansible 1.2.1 and later host key checking is enabled by
default. That means even if you have a password, if you do not have the nodes’
key fingerprints in the <code>known_hosts</code> file on your machine, you cannot ssh on.
I wrote a script to manual get all the fingerprints of remote nodes for the
first time when I encountered this problem …</p>

<p>Then at the time I am reading the docs of ansible, it tells that host key
checking can be disabled by editing <code>/etc/ansible/ansible.cfg</code> or
<code>~/.ansible.cfg</code>:</p>

<p><code>bash
[defaults]
host_key_checking = False
</code></p>

<p>Alternatively this can be set by an environment variable:</p>

<p><code>bash
export ANSIBLE_HOST_KEY_CHECKING=False
</code>
I guess this could let you ssh on remote machine with only password. But I have
not tried it yet. Good luck.</p>

<p>And remember to turn the check on after install your public key on remote host.</p>

<h2 id="create-sysadmin-users-with-initial-password">Create sysadmin users with initial password</h2>

<p>To ensure your password is safe while ssh is creating your account, ansible use
the same technique with linux – your password was hashed using SHA-512
algorithm. For example, if your password is <code>123456</code>, and you write the
following playbook:</p>

<h2 id="yaml">```yaml</h2>
<ul>
  <li>hosts: servers
tasks:
    <ul>
      <li>name: Add SOME_ONE as sysadmin in all the servers
user: name=SOME_ONE groups=sudo password=123456
sudo: yes
```</li>
    </ul>
  </li>
</ul>

<p>It will not work! You have to hash your password. In the
<a href="http://docs.ansible.com/faq.html#how-do-i-generate-crypted-passwords-for-the-user-module">FAQ</a>
of ansible, it provides the following method:</p>

<p><code>bash
mkpasswd YOUR_PASSWD --method=SHA-512
</code></p>

<p>Then fetch the hash value generated, rewrite the playbook like this:</p>

<h2 id="yaml-1">```yaml</h2>
<ul>
  <li>hosts: servers
vars:
  password: THE_HASH_VALUE
tasks:
    <ul>
      <li>name: Add SOME_ONE as sysadmin in all the servers
user: name=SOME_ONE groups=sudo password=
sudo: yes
```</li>
    </ul>
  </li>
</ul>

<p>This will work.</p>

<h2 id="understanding-what-role-is">Understanding what role is</h2>

<p>You should have written some yaml config files to do some simple jobs when you
reach here. As I have did.</p>

<p>To write qualified ansible playbook, roles have been put forward. However, I
think it is better to be called a batch, which means a batch of tasks organized
to do a job, like set up web server on remote host machine.</p>

<p>Understanding role requires you understand the <a href="http://docs.ansible.com/playbooks_roles.html#task-include-files-and-encouraging-reuse">Task Include Files And Encouraging Reuse</a>
part doc of ansible. Roles just include correponding files in the main <code>*.yml</code>
file. Thus if you have playbook config file written like this:</p>

<h2 id="yaml-2">```yaml</h2>

<ul>
  <li>
    <p>hosts: test_machine
user: USER_NAME</p>

    <p>roles:
  - ROLE_ONE
  - ROLE_TWO</p>
  </li>
</ul>

<p>```
ansible will execute the tasks in <code>ROLE_ONE</code> and <code>ROLE_TWO</code> one by one.</p>

<h2 id="ansible-miscellaneous">Ansible Miscellaneous</h2>

<h3 id="tmp-folder-of-ansible">tmp folder of ansible</h3>

<p>Temporarily uploaded files are stored under <code>.ansible/tmp</code> folder under the
user home.</p>

<h3 id="one-task-each-time">One task each time</h3>

<p>Remember to give a name to each task, which reminds you that do not put two
tasks together, like this</p>

<p><code>yaml
copy: src=FILE_ONE dest=FILE_ONE_DEST
copy: src=FILE_TWO dest=FILE_TWO_DEST
</code></p>

<h2 id="a-script-to-quick-check-what-softwares-have-been-installed-by-apt-dpkg-aptitude">A script to quick check what softwares have been installed by apt, dpkg, aptitude</h2>
<p>Some mysterious error could happen when you are installing softwares on remote
machine. To able to have a hint on what happened, have a convenient way to
check the package manager’s log will be helpful.</p>

<p>This <a href="http://linuxcommando.blogspot.com/2008/08/how-to-show-apt-log-history.html">blog</a>
pointed me to this script to view Debian’s package manager’s log:</p>

<p><code>bash
function apt-history(){
      case "$1" in
        install)
              cat /var/log/dpkg.log | grep 'install '
              ;;
        upgrade|remove)
              cat /var/log/dpkg.log | grep $1
              ;;
        rollback)
              cat /var/log/dpkg.log | grep upgrade | \
                  grep "$2" -A10000000 | \
                  grep "$3" -B10000000 | \
                  awk '{print $4"="$5}'
              ;;
        *)
              cat /var/log/dpkg.log
              ;;
      esac
}
</code></p>

<p>Put this into your <code>.bashrc</code>, then for example, <code>apt-history install</code> will show
what packages your have installed in the log.</p>
]]></content>
  </entry>
  
</feed>
