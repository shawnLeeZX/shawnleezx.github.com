<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Emacs | SHAWN LEE]]></title>
  <link href="http://shawnLeeZX.github.io/blog/categories/emacs/atom.xml" rel="self"/>
  <link href="http://shawnLeeZX.github.io/"/>
  <updated>2016-03-08T18:12:56+08:00</updated>
  <id>http://shawnLeeZX.github.io/</id>
  <author>
    <name><![CDATA[Shawn]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[On Code Completion & Navigation for C/C++ in Emacs]]></title>
    <link href="http://shawnLeeZX.github.io/blog/2015/08/11/on-code-completion-for-c-slash-c-plus-plus/"/>
    <updated>2015-08-11T09:21:00+08:00</updated>
    <id>http://shawnLeeZX.github.io/blog/2015/08/11/on-code-completion-for-c-slash-c-plus-plus</id>
    <content type="html"><![CDATA[<p>Due to the same reason that I decided to add <code>company</code> to provide faster and
more accurate completion functionality, I switched from
<a href="http://cedet.sourceforge.net/">CEDET</a> to
<a href="https://github.com/Sarcasm/irony-mode">irony</a> +
<a href="https://github.com/leoliu/ggtags">ggtags</a>.</p>

<p>Here is the note TODO</p>

<!-- more -->

<h2 id="irony">Irony</h2>

<h3 id="installation">Installation</h3>

<p>To setup <code>irony</code>, in the <a href="https://github.com/Sarcasm/irony-mode">README</a> of
<code>irony</code>’s git repo, the installation process provided by the author is pretty
workable. The only thing may need to be noted is that what packages you need to
install if you are not going to compile <code>libclang</code> from source.</p>

<p>In Ubuntu, you need those two packages: <code>libclang-dev</code> and <code>clang</code>. By
mentioning only <code>libclang</code>, it gives me the feeling that I do not need an
executable of <code>clang</code>, however, there is some errors occurs without
<code>clang</code>. But due to the trial and error when making <code>irony-mode</code> to work, I am
not sure it is really caused by lacking of <code>clang</code>.</p>

<h3 id="make-it-work">Make It Work</h3>

<p>You need to let <code>clang</code> know where to find you source file for it to parse
it. To achieve this, <code>irony</code> provides a concept called
<a href="https://github.com/Sarcasm/irony-mode#compilation-database">compilation database</a>. Refer
to it to know how to make <code>irony</code> work. The following is some remarks.</p>

<p>Basically, the most important compilation flags are the include folder path for
header files. Since <code>irony</code> does not aim to provide code navigation function,
all information it needs are in header files.</p>

<p>One problem that bugs me a lot when I was setting up <code>irony</code> is that <code>clang</code> in
<code>irony</code> and <code>gcc</code> handles <code>-I</code> flag differently. The path must immediately
follows the <code>-I</code>, with no spaces. If there are spaces, <code>irony</code> could not find
the corresponding paths.</p>

<h3 id="limitations">Limitations</h3>

<p>During my testing with <code>irony</code>, I found that it could not handle definition
with template, which is used a lot in C++ numerical library. The limitation
also makes sense since that declarations are generated dynamically during
compilation for template definition, so maybe you could not get relevant
information just by parsing the template definition.</p>

<h2 id="ggtags">ggtags</h2>

<p><a href="http://www.gnu.org/software/global/">gtags</a> is better
<a href="http://ctags.sourceforge.net/">ctags</a> in various ways. See the
<a href="https://github.com/leoliu/ggtags">table</a> provided by
<a href="https://github.com/leoliu/ggtags">ggtags</a>’s developers.</p>

<h3 id="setup-system-tags">Setup System Tags</h3>

<p>I copy this section from this
<a href="http://tuhdo.github.io/c-ide.html#sec-7-2">tutorial</a> in case I may forget it.</p>

<p><code>GNU Global</code> has an environment variable named <code>GTAGSLIBPATH</code>. This variable holds
<code>GTAGS</code> database of external libraries that your project depends on but not
inside your project. For example, your project may rely on system headers such
as <code>stdio.h</code>, <code>stdlib.h</code>… but these headers are internal to your project. However,
remember that you can only jump to tag definitions of external dependencies,
and nothing else (such as files or references). But, again, once you are inside
the external library, you can start jumping around sicne it becomes your
current project.</p>

<p>To make <code>GNU Global</code> sees your system headers, follow these steps:</p>

<p>Export this environment variable in your shell init file, such as <code>.bashrc</code> or
<code>.zshrc</code>:</p>

<p><code>bash
export GTAGSLIBPATH=$HOME/.gtags/
</code></p>

<p>Execute these commands in your terminal:</p>

<p>```bash
# Create a directory for holding database, since
# you cannot create a database in your system paths
mkdir ~/.gtags</p>

<h1 id="create-symbolic-links-to-your-external-libraries">Create symbolic links to your external libraries</h1>
<p>ln -s /usr/include usr-include
ln -s /usr/local/include/ usr-local-include</p>

<h1 id="generate-gnu-global-database">Generate GNU Global database</h1>
<p>gtags -c
```</p>

<p>The <code>-c</code> option tells <code>GNU Global</code> to generate tag database in compact format. It
is necessary because if your project contains C++ headers like <code>Boost</code>, without
<code>-c</code> your <code>GTAGS</code> database can be more than 1 GB. Same goes for <code>ctags</code>. The <code>GNU
Global</code> devs explained that it is because the <code>GTAGS</code> database includes the image
of tagged line, and the <code>Boost</code> headers have a lot of very long lines.</p>

<p>After all the above steps, restart with a shell loaded with that variable. To
verify Emacs gets the variable, <code>M-x getenv</code> and enter <code>GTAGSLIBPATH</code> and see
if your predefined value is available. Executing <code>ggtags-find-tag-dwim</code> or
<code>helm-gtags-dwim</code> jumps to the definition of a system tag like a normal tag.</p>

<p>The disadvantage of using <code>GNU Global</code> is that currently it cannot include
files without extension. In the C++ system include directory like
<code>/usr/include/c++/4.8/</code>, it contains files without extension such as
<code>iostream</code>, <code>string</code>, <code>set</code>, <code>map</code>…. so you can write <code>#include</code> directives
without having to append <code>.h</code> at the end. <code>GNU Global</code> devs are considering to
add support for this use case.</p>

<h2 id="some-remarks">Some Remarks</h2>

<ul>
  <li><code>semantic-mode</code> is still used to provide method overview for ECB. It is
configured to only parse current buffer, which is rather acceptable in speed.</li>
  <li>If you want to know more about CEDET, here is
<a href="http://alexott.net/en/writings/emacs-devenv/EmacsCedet.html">a nice introductory post</a>
explaining it.</li>
  <li>Though <code>CEDET</code> gets disabled, company still takes advantage of some part of
tools provided by <code>CEDET</code>. One of them is
<a href="http://cedet.sourceforge.net/ede.shtml">EDE</a>, the project
manager. See the github README page of
<a href="https://github.com/randomphrase/company-c-headers">company-c-headers</a> to see
how could you use <code>EDE</code> to tell <code>company</code> to use system include path.</li>
  <li><a href="https://github.com/emacs-helm/helm">helm</a> is an alternative to
<a href="https://www.masteringemacs.org/article/introduction-to-ido-mode">ido</a>. Maybe
it could be tried while I have more time.</li>
  <li><a href="https://github.com/abingham/emacs-ycmd">emacs-ycmd</a> is another completion
framework for Emacs.</li>
  <li><code>irony</code> offers a flychecker, since I already uses the google style and
cpplint, I will not try <code>flycheck-irony</code> for the time being, though it may
offer advantages such as full compilation error detection.</li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[On Auto Completion in Emacs]]></title>
    <link href="http://shawnLeeZX.github.io/blog/2015/08/11/on-auto-completion-in-emacs/"/>
    <updated>2015-08-11T09:07:00+08:00</updated>
    <id>http://shawnLeeZX.github.io/blog/2015/08/11/on-auto-completion-in-emacs</id>
    <content type="html"><![CDATA[<p>Just finished setting up Emacs using
<a href="http://company-mode.github.io/">company</a> to do auto-completion. Here I would
like to note down the reason why I made the shift from
<a href="https://github.com/auto-complete/auto-complete">auto-complete</a> to <code>company</code>
for programming. However, for tasks like writing configuration file, LaTeX
documents or markdown note, I still use <code>auto-complete</code>.</p>

<!-- more -->

<h2 id="comparison-between-company-and-auto-complete">Comparison Between <code>company</code> and <code>auto-complete</code></h2>

<p>At the first iteration of my Emacs configuration for C/C++, I followed the
following three videos to get a basic setup:</p>

<ul>
  <li><a href="https://www.youtube.com/watch?v=HTUE03LnaXA">Emacs as a C/C++ Editor/IDE (Part I): auto-complete, yasnippet, and autoplete</a></li>
  <li><a href="https://www.youtube.com/watch?v=r_HW0EB67eY">Emacs as a C/C++ Editor/IDE (Part 2): iedit, flymake-google-cpplint, google-c-style</a></li>
  <li><a href="https://www.youtube.com/watch?v=Ib914gNr0ys">Emacs as a C/C++ Editor/IDE (Part 3): Installing CEDET mode for true intellisense</a></li>
</ul>

<p>which introduces the <code>auto-complete</code> for doing automatically completion.</p>

<p>At the same time, the extension
 <a href="https://github.com/tkf/emacs-jedi">emacs-jedi</a> only supports <code>auto-complete</code>
backend. And <code>emacs-jedi</code> is the only python code completion extension for
Emacs at then, which turns out that there were a number of others I did not
notice(see previously post on Python in Emacs). So I decided to use
auto-complete.</p>

<p>Then as the projects I worked on got bigger, the possible candidates provided
by <code>auto-complete</code> becomes too large to be useful due to the reason that
<code>auto-complete</code> will fetch all candidates from all sources.</p>

<p>The same problem happens to <code>auto-complete</code> in file path completion as
well. You get a lot of non-sense completion when you only want to get
completion in the path you want, which is a rather narrow space in the whole
space of all your possible completion candidates.</p>

<p>There could be a way to dynamically change the order of sources, but <code>company</code>
seems to do this automatically or people writes the backends for <code>company</code> do
this. In whatever case, the user does not need to attend to those things.</p>

<p>That is not the fatal problem yet, <code>auto-complete</code> has a annoying problem which
I do not know how to fix is that the time needed for the completion list to
respond to new input is at the magnitude of seconds. I am pretty sure this is
not a performance problem given that the completion list comes up pretty fast.</p>

<p><code>company</code> also solves the file completion problem and c headers completion
problem by providing a separate function in their respective backends, which I
just need to map another key binding to it so the completion will be very
accurate when you are programming.</p>

<p><code>auto-complete</code> does good when you are writing text heavy contents such as
LaTeX or markdown but not logically heavy ones such as programming language.</p>

<p>For a more complete comparison you could refer to the end of the 
<a href="http://company-mode.github.io/">github page</a> of <code>company</code>.</p>

<h2 id="on-using-them-together">On Using Them Together</h2>

<p>One more realization is that those two extensions are not exclusive at all. I
did not find a backend like the sources provided by <code>auto-complete</code> for
complete word in buffers related functions, which is the area <code>auto-complete</code> 
works well.</p>

<p>Below is some sample on how to use them from my
<a href="https://github.com/shawnLeeZX/emacs.d">Emacs configuration</a>.</p>

<p>```cl
(add-hook ‘after-init-hook ‘global-company-mode)</p>

<p>;;   “Modes for which <code>company-mode' mode is turned on by
;; </code>global-company-mode’.  If nil, means no modes.  If t, then all major modes
;; have it turned on.  If a list, it should be a list of <code>major-mode' symbol
;; names for which </code>company-mode’ should be automatically turned on.  The sense
;; of the list is negated if it begins with <code>not'.  For example: (c-mode
;; c++-mode) means that </code>company-mode’ is turned on for buffers in C and C++
;; modes only.  (not message-mode) means that <code>company-mode' is always turned
;; on except in </code>message-mode’ buffers.”
(setq company-global-modes ‘(
                            c-mode
                            c++-mode
                            ))
```</p>

<p><code>cl
;; Enable auto-complete for modes in ac-modes by default.
(global-auto-complete-mode t)
;; We reset the default mode for auto-complete given that we want to some modes
;; to use company-mode.
(set-default 'ac-modes
             '(
               magit-log-edit-mode
               log-edit-mode org-mode text-mode haml-mode
               git-commit-mode
               conf-mode conf-unix-mode conf-colon-mode
               inferior-emacs-lisp-mode inferior-python-mode
               sql-interactive-mode
               sass-mode yaml-mode csv-mode espresso-mode haskell-mode
               html-mode nxml-mode smarty-mode clojure-mode
               lisp-mode textile-mode markdown-mode tuareg-mode
               js3-mode css-mode less-css-mode sql-mode
               web-mode
               ))
</code></p>

<h2 id="difference-between-tab-and-tab">Difference Between <tab> and TAB</tab></h2>

<p>The last thing I want to note down is that TAB key.</p>

<p>Emacs has two tabs, <code>(kbd "&lt;tab&gt;")</code> and <code>(kbd "TAB")</code>. To make things more
complex, <code>yasnippet</code>, <code>auto-complete</code>, indentation in Emacs, typing real tab
stops and <code>company</code> all uses <code>tab</code>, which makes it very complicated.</p>

<p>From this
<a href="https://www.reddit.com/r/emacs/comments/2aemny/difference_between_tab_and_tab/">thread</a>
in Reddit, here, I knew that <code>(kbd "&lt;tab&gt;")</code> stands for the physical key you
have pressed and <code>(kbd "TAB")</code> stands for the control character. So to speak,
normally, if you are not binding <code>&lt;tab&gt;</code> to <code>TAB</code>, the tab you typed is not
actually the control character TAB, but triggers some function that is hooked
on the physical key’s response.</p>

<p>As for the second part of the puzzle, when you are typing tab at a location
where the indentation of the statement is not right, Emacs will indent your
line first. The key to differentiate <code>yasnippet</code> and <code>auto-complete</code> is whether
you are typing or not when you pressed the tab key. If you are, completion menu
will be triggered, if you are not <code>yasnippet</code> will be triggered(this is a
mechanism that could be configured in auto-complete and is not the default, by
default, I think the completion menu will pop up automatically). As for
<code>company</code> and <code>yasnippet</code>, in my experiments, after setting the trigger key to
tab, by default it seems that snippets are always gotten expanded the first,
then <code>company-complete</code> will be triggered if no snippets could be found. See
the following code snippets for how to set up key binding for <code>company</code>(it only
uses <code>company</code> if <code>irony-mode</code> is in usage).</p>

<p><code>cl
;; Setup keymapping for company-complete.
(add-hook 'irony-mode-hook (lambda ()
                             (local-set-key (kbd "&lt;tab&gt;") 'company-complete-common)
                             (local-set-key (kbd "C-c C-f") 'company-files)
                             ))
</code></p>

<h2 id="reference">Reference</h2>

<ul>
  <li><a href="https://www.youtube.com/watch?v=HTUE03LnaXA">Emacs as a C/C++ Editor/IDE (Part I): auto-complete, yasnippet, and autoplete</a></li>
  <li><a href="https://www.youtube.com/watch?v=r_HW0EB67eY">Emacs as a C/C++ Editor/IDE (Part 2): iedit, flymake-google-cpplint, google-c-style</a></li>
  <li><a href="https://www.youtube.com/watch?v=Ib914gNr0ys">Emacs as a C/C++ Editor/IDE (Part 3): Installing CEDET mode for true intellisense</a></li>
  <li><a href="http://tuhdo.github.io/c-ide.html">tutorial on customizing C/C++ environment for emacs</a></li>
  <li><a href="https://www.masteringemacs.org/article/mastering-key-bindings-emacs">Mastering Key Bindings in Emacs</a></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[On IDEs of Python in Emacs]]></title>
    <link href="http://shawnLeeZX.github.io/blog/2015/08/05/on-ides-of-python-in-emacs/"/>
    <updated>2015-08-05T10:30:00+08:00</updated>
    <id>http://shawnLeeZX.github.io/blog/2015/08/05/on-ides-of-python-in-emacs</id>
    <content type="html"><![CDATA[<p>I was finally annoyed enough to find a replacement of <code>auto-complete</code> in
Emacs. Reasons will be noted down later. In this note, three common extensions
for writing Python under Emacs will be compared and noted, which are:</p>

<ol>
  <li><a href="https://github.com/tkf/emacs-jedi">jedi</a></li>
  <li><a href="https://github.com/jorgenschaefer/elpy">elpy</a></li>
  <li><a href="https://github.com/proofit404/anaconda-mode">anaconda</a></li>
</ol>

<!-- more -->

<p>I always used emacs-jedi since I made the shift from Vim to Emacs.</p>

<p>The functionality provided by emacs-jedi is actually quite good. The only function
that lacks is the one to refactor. So it is not the fault of emacs-jedi that makes me
want to change extensions. However, the detail will be left to the comparison
between <code>company-mode</code> and <code>auto-complete</code>.</p>

<p>Though emacs-jedi is not bad, it is also not that good compared with elpy, in my
opinion.</p>

<p>You could get good code completion, etc, basically everything roughly equal in
those three extensions. There are some details about elpy that makes me prefer
to elpy.</p>

<p>At the time that I set up emacs-jedi, basically I copied some the author’s hacking
code to let emacs-jedi recognize my current python files, or project
automatically. It works, but it does not feel elegant.</p>

<p>I could get by with that if it is not due to the reason of <code>auto-complete</code>.</p>

<p>With elpy, you could use command <code>elpy-set-project-root</code> to tell elpy that you
need current project to be taken into account, which does not feel
automatically but it is more user friendly and elegant.</p>

<p>What’s more, elpy takes into account the <code>PYTHON_PATH</code> environment variable
into account automatically. I guess emacs-jedi does this as well.</p>

<p>As for anaconda, actually I found it prior to elpy and also gave it a
try. However, it failed when I tried to get code completion on-the-fly in my
current project and no documentation seems to hint me how to deal with that.</p>

<p>Lastly, the refactoring function provided by elpy seems exciting so that I
won’t need to use <code>search-and-replace</code> or <code>multi-occur</code> stuff. But I did not
try it yet. Look forward to.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Small Emacs auto-complete-mode Trick]]></title>
    <link href="http://shawnLeeZX.github.io/blog/2015/08/01/small-emacs-auto-complete-mode-trick/"/>
    <updated>2015-08-01T14:15:00+08:00</updated>
    <id>http://shawnLeeZX.github.io/blog/2015/08/01/small-emacs-auto-complete-mode-trick</id>
    <content type="html"><![CDATA[<p>Just knew another small trick. Note it down in case I forgot it.</p>

<p><code>cl
(eval-after-load "auto-complete" '(add-to-list 'ac-modes 'lua-mode)).
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Open File Using External App in Emacs]]></title>
    <link href="http://shawnLeeZX.github.io/blog/2014/12/08/open-file-using-external-app-in-emacs/"/>
    <updated>2014-12-08T14:29:00+08:00</updated>
    <id>http://shawnLeeZX.github.io/blog/2014/12/08/open-file-using-external-app-in-emacs</id>
    <content type="html"><![CDATA[<p>It would be of great convenience to be able to open files in
<code>dired-mode</code> in Emacs using external apps. Here is how to achieve it.</p>

<!-- more -->

<p>```cl
;;; Add command to open file using system programs.
;; ===================================================================
(defun open-in-external-app (&amp;optional file)
  “Open the current file or dired marked files in external app. The app
is chosen from your OS’s preference.”
  (interactive)</p>

<p>(let ( confirm
         (file-list
          (cond
           ((string-equal major-mode “dired-mode”) (dired-get-marked-files))
           ((not file) (list (buffer-file-name)))
           (file (list file))
           )
          )
         )</p>

<pre><code>(setq confirm (if (&lt;= (length file-list) 5)
               t
             (y-or-n-p "Open more than 5 files? ")
             )
      )

(when confirm
  (cond
   ((string-equal system-type "windows-nt")
    (mapc
     (lambda (file-path)
       (w32-shell-execute "open"
                          (replace-regexp-in-string "/" "\\" file-path t t)
                          )
       )
     file-list)
    )
   ((string-equal system-type "darwin")
    (mapc
     (lambda (file-path)
       (shell-command (format "open \"%s\"" file-path))
       )
     file-list)
    )
   ((string-equal system-type "gnu/linux")
    (mapc
     (lambda (file-path)
       (let ((process-connection-type nil))
         (start-process "" nil "xdg-open" file-path)
         )
       )
     file-list)
    )
   )
  )
)   ) ```
</code></pre>

<p>I learned this from
<a href="http://ergoemacs.org/emacs/emacs_dired_open_file_in_ext_apps.html">here</a>. However,
the code here is more readable and conformed to the programming
convention of Elisp.</p>
]]></content>
  </entry>
  
</feed>
