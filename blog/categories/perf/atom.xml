<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Perf | SHAWN LEE]]></title>
  <link href="http://shawnLeeZX.github.io/blog/categories/perf/atom.xml" rel="self"/>
  <link href="http://shawnLeeZX.github.io/"/>
  <updated>2015-11-30T11:44:37+08:00</updated>
  <id>http://shawnLeeZX.github.io/</id>
  <author>
    <name><![CDATA[Shawn]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[通过profile来了解系统运行]]></title>
    <link href="http://shawnLeeZX.github.io/blog/2013/12/13/tong-guo-profilelai-liao-jie-xi-tong-yun-xing/"/>
    <updated>2013-12-13T21:49:00+08:00</updated>
    <id>http://shawnLeeZX.github.io/blog/2013/12/13/tong-guo-profilelai-liao-jie-xi-tong-yun-xing</id>
    <content type="html"><![CDATA[<p>最近在阅读Light Weight TCP/IP
Stack(LWIP)的源码，对于其核心的tcpip_thread在何时被加载不解，在探索过程中有了此篇文章中的内容。同时在此感谢本课程助教的帮助告知我在每个动态库可以指定在被加载时和卸载时的初始化和清理函数，具体会在之后的内容中提及。</p>

<p>本文使用的所有代码在<a href="/resources/profile/profile_source.tar.gz">这里</a>。</p>

<!-- more -->

<h2 id="profile">Profile工具</h2>

<h3 id="perf">perf</h3>

<p>本文适用的profile工具为perf。perf是Linux下的程序性能分析工具，更多内容见perf的<a href="https://perf.wiki.kernel.org/index.php/Main_Page">wiki</a>。</p>

<p>本来我用的是oprofile，但是其总是莫明其妙地出问题，于是找替代找到了perf。觉得oprofile不好用。</p>

<h3 id="gprof">gprof</h3>

<p>另外提一下另一个GNU系列的gprof，其也是一个性能分析工具。其和perf和oprofile的区别在于其不是通过内核的探测CPU等产生的事件来进行性能统计，而是在编译时直接在代码中添加用于数据统计的代码。所以gprof到目前我所探索的有限功能为止，我觉得只能用于检测不涉及内核的程序——需要profile的代码不位于内核中，想要profile的进程或者线程不是由内核建立（这一点就使其不能用于profile
lwip）。</p>

<p>虽然适用范围有限，但是其产生的信息非常详尽，所以如果可以用是非常好地。这里是一个使用<a href="http://www.thegeekstuff.com/2012/08/gprof-tutorial/">教程</a>。</p>

<h3 id="gprof2dot">gprof2dot</h3>

<p>gprof2dot是一个将profile工具产生的数据转化为直观的图形现实的工具，对工作效率的提升可谓之为神器。使用只需要两个python脚本——<a href="/resources/profile/grof2dot.py">gprof2dot.py</a>和<a href="/resources/profile/xdot.py">xdot.py</a>。前者用于产生图像数据，后者用于交互式地查看图像。</p>

<h2 id="section">单线程程序</h2>

<p>第一个看看简单c程序。</p>

<p>我们拟profile下面这个程序，one_thread_profile.c：</p>

<p>```c
#include <math.h></math.h></p>

<h1 id="define-power-8">define POWER 8</h1>

<p>int a = 0;</p>

<p>void increment_a()
{
  a++;
}</p>

<p>int main (int argc, char const* argv[])
{
    for (int i = 0; i &lt; (int)pow(10, 8); i++)
      {
        a++;
        increment_a();
      }</p>

<pre><code>return 0; } ```
</code></pre>

<p>分析程序使用命令如下：
<code>bash
g++ -g one_thread_profile.c
perf record -g -e cycles:u ./a.out
perf script | gprof2dot.py -f perf | xdot.py
</code>
perf命令解释：</p>

<ul>
  <li><code>-e cycles:u</code>表示仅记录用户态的事件，这样使得输出的结果更加简单易读。</li>
  <li><code>-g</code>表示产生函数调用图。</li>
</ul>

<p>grof2dot命令解释：</p>

<ul>
  <li><code>-f</code>表示使用的数据是perf产生的格式。</li>
</ul>

<p>如此得到如下的性能分析结果图：</p>

<p>{% img center /resources/profile/one_thread_profile.png “One thread profile result” “One thread profile result” %}</p>

<p>最右侧是涉及到perf的部分，应是由于统计需要而引入的额外开销。右上角是的ld-2.15是linux用于加载共享库的共享库（即用于加载以<code>*.so</code>为后缀的共享库）。</p>

<p>而在左侧，则可以清晰地看见c的库函数对入口main函数的调用，然后main函数对increment_a()的调用。</p>

<p><strong>注</strong>：之后对于perf以及ld产生的开销以及如何产生分析图不再说明。</p>

<h2 id="section-1">多线程程序</h2>

<p>之后的实例程序的编译只要使用相应Makefile即可。</p>

<p>多线程程序的代码two_thread_profile如下：</p>

<p>```c
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>
#include <math.h></math.h></unistd.h></pthread.h></stdlib.h></stdio.h></p>

<h1 id="define-power-8-1">define POWER 8</h1>

<p>pthread_t new_thread;</p>

<p>void looper()
{
  int a = 0;
  for (int i = 0; i &lt; (int)pow(10, 8); i++)
    {
      a++;
    }
}</p>

<p>void *thread_function(void *arg)
{
    looper();
    return ((void *)0);
}</p>

<p>int main (int argc, char const* argv[])
{
    int err;</p>

<pre><code>err = pthread_create(&amp;new_thread, NULL, thread_function, NULL);
if (err != 0)
{
    printf("Err when create thread.\n");
    exit(err);
}
looper();

sleep(1);
exit(0); } ```
</code></pre>

<p>程序分两个线程，分别调用<code>looper()</code>进行循环。</p>

<p>得到分析结果如下图：</p>

<p>{% img center /resources/profile/two_thread_profile.png “Two thread profile result” “Two thread profile result” %}</p>

<p>可以看到，c共享函数库负责main函数，而pthread共享函数库负责多产生出的一个线程。</p>

<h2 id="section-2">静态链接库与共享链接库</h2>

<p>有关链接库的教程看<a href="http://www.tldp.org/HOWTO/Program-Library-HOWTO/">这里</a>。</p>

<p>代码就不粘在这里了，当将循环部分做成库函数放入静态以及共享链接库时，分别得到如下两个结果。</p>

<p>{% imgcap center /resources/profile/static_profile.png Static library profile result%}
{% imgcap center /resources/profile/shared_profile.png Shared library profile result%}</p>

<p>可以看到，静态链接库的内容被直接放到了main里，而共享链接库则是通过调用实现。</p>

<h2 id="section-3">在加载时被初始化的共享链接库</h2>

<p>最终回到lwip上，当使用lwip的网络功能时。对于一个使用BSD-Style的简单服务器端select_server，其接受socket传来的数据之后直接丢弃数据，使用perf得到的结果图如下。</p>

<p>{% imgcap center /resources/profile/select_server.png 简单服务器分析图%}</p>

<p>对于一个简单的http服务器，使用perf得到的结果图如下。</p>

<p>{% imgcap center /resources/profile/rawt_http.png 简单http服务器分析图%}</p>

<p>在这两个分析图中，存在一个内核的函数对liblwip.so的调用（由于我的内核镜像没有代码信息，所以只能显示地址）——liblwip.so即是用于使用lwip的共享函数库。为什么会存在这种情况？</p>

<p>通过询问助教，得知每个动态库可以指定在被加载时和卸载时的初始化和清理函数。</p>

<p>实现的方式有两种，第一种如下，需要在编译生成so库时指定-nostartfiles选项。（函数名固定）</p>

<p>```c
void _init(void)
{
    ……
}</p>

<p>void _fini(void)
{
    ……
}
```</p>

<p>这种方式现在不提倡，倾向于使用第二种。第二种使用gcc的扩展，如下：（函数名可以自定义）</p>

<p><code>c
void __attribute__((constructor)) libso_init(void)
{
    ......
}
</code></p>

<p><code>
void __attribute__((destructor)) libso_fini(void)
{
    ......
}
</code></p>

<p>再进一步就没有进行探索了，现阶段的结论应该是对函数库的初始化函数的调用是有操作系统内核完成。</p>
]]></content>
  </entry>
  
</feed>
