<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Linux | SHAWN LEE]]></title>
  <link href="http://shawnLeeZX.github.io/blog/categories/linux/atom.xml" rel="self"/>
  <link href="http://shawnLeeZX.github.io/"/>
  <updated>2016-03-08T17:52:07+08:00</updated>
  <id>http://shawnLeeZX.github.io/</id>
  <author>
    <name><![CDATA[Shawn]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Note on Installing Ubuntu on Newer Machines]]></title>
    <link href="http://shawnLeeZX.github.io/blog/2016/03/08/note-on-installing-ubuntu-on-newer-machines/"/>
    <updated>2016-03-08T13:48:00+08:00</updated>
    <id>http://shawnLeeZX.github.io/blog/2016/03/08/note-on-installing-ubuntu-on-newer-machines</id>
    <content type="html"><![CDATA[<p>This is the note supposed to note something peculiar things I met during
setting up Ubuntu on a newer machine, which is to say, with UEFI replacing
BIOS, GPT replacing MBR, Display Port and HDMI replacing VGA and DVI, and with
several GPUs.</p>

<p>Due to time reason, I fell back to my old way of installing Ubuntu, and have
not figured out what is the right way to install the newer machine mentioned
above, but the note is to note down possible guess, and the things have been
figured out, so I may have a thread to follow next time.</p>

<!-- more -->

<p>At the time I entered what was called BIOS of the machine, which is called
UEFI(Unified Extensible Firmware Interface), I was amazed that it was an almost
desktop GUI. The official lab machine of mine has a similar firmware, but since
I was not supposed to have access to it, I did not play with it much. I think
my most recent laptop should have also used UEFI, but I did not have any memory
what it is like, I guess I did not need to change things so I did not enter it.</p>

<h2 id="gpu-control-from-boot-to-os">GPU Control From Boot to OS</h2>

<p>The first thing I tried to figure out is how a GPU could be installed
properly. In other words, how could a GPU inserted in a socket could be
detected by the motherboard, then OS?</p>

<p>Normally a PC motherboard has an integrated card, and an optional discrete
graphical unit could be installed GPU card through PCIE sockets. There is a
switch in the UEFI to tell the motherboard where to look for a graphical
unit. Also, even if the GPU is not powered up, I could have a hint on the
monitor to tell me to what happened. So I think a GPU has a basic function unit
that offers motherboard basic graphical function so it could be used till the
machine boots into an OS.</p>

<p>The first problem I have met is there was no output when I connect DVI adapter
of the monitor to a TITAN Black that was inserted in the latter socket of the
motherboard, and could only get output when I connect the adapter to the GPU
inserted in the first PCIE socket. The GPU is not a TITAN Black but a 760.</p>

<p>There are two guesses why this situations happen. The first is UEFI only detect
GPU at the first PCIE socket and ignores all the remaining. This is reasonable
since no one is supposed to use multiple GPUs during boot time. But it seems I
have tried put a TITAN Black at the first socket, though I cannot clearly
remember it. So another guess is my current UEFI does not support TITAN at boot
time.</p>

<p>After the UEFI transfer the control to OS, the drivers in UEFI should not
function anymore. So drivers need to be installed in the OS.</p>

<p>The open source NVIDIA card driver, Nouveau, will be installed when installing
Ubuntu. I thought only when a NVIDIA GPU is physically inserted, its open
source driver would be installed. However, it seems the open source driver will
be installed even without a card. Maybe it is because in this case, a GPU card
could be used right after installation without re-installing kernel modules.</p>

<p>Nouveau has to be removed if I want to install the newest driver from NVIDIA
through the <code>*run</code> file, otherwise they would conflict. To do this, a file
needs to be added to <code>/etc/modprobe.d/</code> with the following contents.</p>

<p><code>
# generated by nvidia-installer
blacklist nouveau
options nouveau modeset=0
</code></p>

<p>It is actually generated by the <code>*run</code> file. I think it tells kernel not to
load nouveau module.</p>

<p>Then regenerate your kernel</p>

<p><code>
update-initramfs -u
</code></p>

<p>To completely wipe out <code>nouveau</code> — though I think even without doing it, it
would work, run the following command</p>

<p><code>
sudo apt-get remove xserver-xorg-video-nouveau
</code></p>

<p>To run <code>*run</code> file, one needs to log into a text console. A way I could find
that is commonly suggested on the web is to switch to one virtual terminal by
`Ctrl+Alt+F1’, then stop the X service</p>

<p><code>
sudo stop lightdm   or
sudo lightdm stop
</code></p>

<p>It did not work for me. So I need to reboot into text mode by editing
grub. More concretely, when the grub menu pops up, press <code>e</code> on the item, and
find <code>splash quiet</code>, and change it to <code>text</code>, then press <code>F10</code> to boot using
current edited entry.</p>

<p>One last thing before running the <code>*run</code> file. The <code>*run</code> file will build GPU
driver to kernel, but only once. So if your OS gets upgraded, you won’t be able
to log in desktop again. To work get around this, we need to install <code>dkms</code>, so
each time the kernel gets upgraded, all modules already built will be
automatically built again into the kernel.</p>

<p><code>
sudo apt-get install dkms
</code></p>

<p>All are settled, just run the <code>*run</code> file to install the driver.</p>

<p>To see what modules has been managed by <code>dkms</code>, use <code>dkms status</code>.</p>

<p>One last thing that tricked me up is to tell motherboard to use discrete
graphical unit after the driver has been installed. Otherwise, I could still
make it till the GUI login page, but after I have input my password, the screen
just flash a little, and ask me to log in again. I guess the problem is
since motherboard is configured to use integrated graphical unit, so the
discrete one is actually inactive, when <code>xorg.conf' tells </code>X11` to use the
discrete graphical unit, nothing is there. The solution is just to fall back.</p>

<p>I also have some guess on how <code>X11</code> make use of multiple GPUs. I have two
versions of <code>xorg.conf</code>, one from my official lab machine, and one from the one
I am setting up.</p>

<p>The official one</p>

<p>```
Section “Device”
    Identifier     “Device0”
    Driver         “nvidia”
    VendorName     “NVIDIA Corporation”
    BoardName      “GeForce GTX TITAN Black”
EndSection</p>

<p>Section “Device”
    Identifier     “Device1”
    Driver         “nvidia”
    VendorName     “NVIDIA Corporation”
    BoardName      “GeForce GTX TITAN Black”
    BusID          “PCI:1:0:0”
    Screen          1
EndSection
```</p>

<p>The other one is just</p>

<p><code>
Section "Device"
    Identifier     "Device0"
    Driver         "nvidia"
    VendorName     "NVIDIA Corporation"
EndSection
</code></p>

<p>The first one is generated by <code>nvidia-settings', the second one is generated by
</code>*run` file. I have three TITAN Black installed on the motherboard with the
second configuration file, and they are all functional.</p>

<p>The guess now is if no bus id is specified in <code>xorg.conf</code>, <code>X11</code> could pick any
one, and prefer to the one with lowest PCI id or GPU id.</p>

<p>A side note. To get the bus id of a card, use <code>lspci</code>, which output corresponds
to GPU is</p>

<p><code>
01:00.0 VGA compatible controller: NVIDIA Corporation GK110B [GeForce GTX TITAN Black] (rev a1)
</code></p>

<p><code>01:00.0</code> is the bus id, though I am still now know why the period becomes a colon.</p>

<h2 id="note-on-cuda">Note On CUDA</h2>

<p>After all those efforts to install NVIDIA driver through <code>*run</code> file, I found
<code>cuda</code> installation(using the network deb provided by NVIDIA) just overrided
the driver I have just installed…</p>

<p>I am not sure whether dkms will be automatically installed, or nouveau be
automatically blacklisted, though the installation of cuda does not mention it,
which is to mean they probably will take care of this. If this is so the
installation of NVIDIA driver and CUDA will be much easier.</p>

<p>I notice the <code>xorg.conf</code> is not changed after the ``new’’ driver being
installed.</p>

<h2 id="bios-mode-or-uefi-mode-ubuntu">BIOS mode or UEFI mode Ubuntu</h2>

<p>The last set of note is about installing Ubuntu in BIOS mode or UEFI mode,
which corresponds to using MBR or GPT partition table, and may be some other
difference.</p>

<p>At the time when choosing the boot media, even if your USB only has one Ubuntu
on it, the boot menu would show up as entries, one for normal BIOS mode
ubuntu(which is just named Ubuntu), one for UEFI mode(which has a UEFI in the
name). I have not tried the second one. The UEFI is a pretty new thing to me,
since the last time I learned something about it, UEFI is still in its
infancy.</p>

<p>If UEFI is chosen, the partition table of the hard disk where the boot loader
would be installed must be GPT, which is written in the new standard. The boot
loader of MBR and GPT are different(obviously). For GPT, an explicitly
formatted and allocated partition seems to be needed(not verified). As for MBR,
as everyone knows, the space for the boot loader will always be left out. Also,
to boot from a GPT partitioned disk, a boot flag need to be marked on the disk,
otherwise, OS won’t boot. There are still many other difference I have not
figured out yet.</p>

<h2 id="reference">Reference</h2>

<ol>
  <li><a href="http://www.linuxsecrets.com/blog/15questions-troubleshooting/2015/09/10/1651-how-to-remove-nouveau-and-install-nvidia-drivers">How to Remove Nouveau and Install Nvidia Drivers</a></li>
</ol>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[VLC下使用中文字幕]]></title>
    <link href="http://shawnLeeZX.github.io/blog/2016/02/16/vlcxia-shi-yong-zhong-wen-zi-mu/"/>
    <updated>2016-02-16T22:00:00+08:00</updated>
    <id>http://shawnLeeZX.github.io/blog/2016/02/16/vlcxia-shi-yong-zhong-wen-zi-mu</id>
    <content type="html"><![CDATA[<p>记如何在VLC下使用中文字幕。</p>

<!-- more -->

<p>默认状态下，VLC会遇到两个问题，一是解码的codecs所用不对，而是用于显示字体的渲染
器(render)所用字体不对。</p>

<p>第一个问题的解决办法一是更改VLC所用的codecs；二是修改文件的codecs为utf-8。第一
种方法在<a href="http://bbs.feng.com/read-htm-tid-344593.html">这里</a>有介绍。第二种方法
我发现Vim可以完美完成，特此记之。</p>

<p>用Vim打开字幕文件，然后使用如下命令：</p>

<p><code>
:set fileencoding=utf-8
</code></p>

<p>保存，退出。</p>

<p>第二个问题的解决也来自之上的
<a href="http://bbs.feng.com/read-htm-tid-344593.html">链接</a>。为防止链接失效，特此重述
方法：</p>

<p>打开VLC的<code>Preferences</code>窗口（<code>Ctrl+P</code>），点击右下角的<code>all</code>，在左边的索引中依次选择
<code>Video -&gt; Subtitles/OSD -&gt; Text renderer</code>，右边的设置区第一项为<code>Font</code>，点击<code>Browse</code>按
钮选择一项中文字体，如<code>WenQuanYi Micro Hei</code>。更改完成之后需要重启VLC。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Setting up Multi-Monitor on Gnome Ubuntu 14.04 with NVIDIA Card]]></title>
    <link href="http://shawnLeeZX.github.io/blog/2016/01/06/setting-up-multi-monitor-on-gnome-ubuntu-14-dot-04-with-nvidia-card/"/>
    <updated>2016-01-06T08:16:00+08:00</updated>
    <id>http://shawnLeeZX.github.io/blog/2016/01/06/setting-up-multi-monitor-on-gnome-ubuntu-14-dot-04-with-nvidia-card</id>
    <content type="html"><![CDATA[<p>I got an old monitor and spent some time tweaking the dual monitor setting of
my PC in the office. Here I note down</p>

<ol>
  <li>a tweak to make multiple monitor in Gnome functions better, and some notes
on the behavior of <code>guake</code> under multi-monitor setting.</li>
  <li>a hack to let X Windows remember the monitor layout</li>
  <li>and a short comparison between Gnome 3 and KDE Plasma 4.</li>
</ol>

<!-- more -->

<h2 id="dual-monitor-on-gnome">Dual Monitor on Gnome</h2>

<p>I uses <a href="https://www.gnome.org/">Gnome</a> as my desktop environment ever since the
time I started using Linux. So naturally, the desktop I tried this time to
manage multi-monitor support is Gnome. By default, the dual monitor worked
pretty OK. The only one thing that may need a tweak is: by default, Gnome(my
version is 3.9.90), only supports workspace in primary monitor, so when you
switch back and forth between different workspace, the secondary monitor stays
fixed on whatever it is on. This kind of makes the extra monitor many times
less useful. To make the secondary monitor attach to current workspace, so it
moves when you switch workspaces, you need to configure Gnome a little bit, by
the following command</p>

<p><code>bash
gsettings set org.gnome.shell.overrides workspaces-only-on-primary false
</code></p>

<p>One drawback of making such a change is <code>guake</code> will stay on the secondary
window forever. Did not get the time to look into the source code to know why
:(.</p>

<p><em>Updated on Jan 9, 2016.</em></p>

<strike>It is weird. `guake` functions normally now, after a reboot. This is probably
not the first time I reboot. I guess it is the package updates that fixed
something.</strike>

<p>I figured out why. When you maximize <code>guake</code> it sticks with that monitor, but
your cancel maximization, it would reconsider it position by probing which
monitor the mouse is in and set itself there.</p>

<h2 id="physical-layout-of-monitors">Physical Layout of Monitors</h2>

<p>I do not know how much it depends on operating system, drivers and
hardware. The <code>display</code>(the GUI one of Gnome) or <code>nvidia-settings</code>(the CLI one
comes with proprietary driver) forgets the monitor layout after reboot, such as
<code>DVI-I-1</code> should be on the left of <code>DVI-D-0</code>, even if I wrote it in the
<code>xorg.conf</code>.</p>

<p>Though finally I switched the monitors physically, for some other reason, and
made peace with the forgetful display manager, I struggled some time to figure
out how to make the layout right.</p>

<p>The solution I used is to use <code>xrandr</code> after the GUI session has set up by
adding a script containing the following line in the startup application of
Gnome(there is a GUI program called <code>Startup Application</code>, though I do not know
what its CLI version is).</p>

<p><code>
xrandr --output DVI-I-1 --mode 1920x1080 --right-of DVI-D-0
</code></p>

<p>I also have tried to add the above line in <code>.profile</code>, but it seems the layout
setting is decided after <code>.profile</code> is loaded, so it did not work.</p>

<h2 id="a-peak-at-kde">A Peak at KDE</h2>

<p>At the first time I tried to set <code>workspaces-only-on-primary</code> to <code>false</code>, it
did not have any effect, and first all workspaces other than the first one
started to get severe artifact when moving windows around, then even the first
one started to get artifacts. It made the desktop unusable.</p>

<p>After trying to search for an solution in Google for a while, I learned there
seems Gnome do not have any multi-monitor support at all, at least they do not
consider this a feature to be proud of at their website for Gnome 3. So I think
maybe Gnome does not work for Gnome.</p>

<p>Then some video introducing Plasma let me pay some attention to KDE
desktop. The modern design of KDE Plasma 5.5 really impressed me, though in
retrospect I was dazzled by Gnome 3’s new design at the first I saw it. It is
just the case that I have been used to Gnome 3 for such a long time and do not
feel its design at all now.</p>

<p>I installed Plasma from source by</p>

<p><code>bash
sudo apt-get install kubuntu-desktop
</code></p>

<p>This is the first time I started to feel Ubuntu 14.04 is getting old. It only
has Plasma 4.14(the minor version may not be right, but it is 4).</p>

<p>After tinkering it a little bit, though it must be the case I did not get
myself familiar with it, I have the first impression as following:</p>

<ol>
  <li>It seems to have many widgets, which is better than Gnome, whose desktop
widget feels like antiques.</li>
</ol>

<p>Besides that, I did not find an obvious solution to</p>

<ol>
  <li>multiple workspaces, which is available by default in Gnome</li>
  <li>the dash application runner(I am not sure its exact name, just you press the
<code>super</code> or <code>win</code> key in you desktop and it shows up). I tried to install
a app called <code>homerun</code>, but it just adds too much icons in the desktop and
creates too much clutters.</li>
  <li>Obvious, <code>guake</code> does not work here anymore.</li>
</ol>

<p>The above three are really killer app, and cannot not be lacking.</p>

<p>So the first impression is KDE is for the GUI users.</p>

<ol>
  <li>It has a good file manager called <code>Dolphin</code>, whose functionality is better
than <code>Nautilus</code>. But I almost do not use GUI file management since I do it
all in CLI.</li>
  <li>A similar application launcher of dash of Gnome is <code>Krunner</code>. But like
Unity, it not only search for applications, but also search for files, any
opened applications etc, which creates much clutter, though this is a
desktop user wants.</li>
  <li>Again, no easy drop-down terminal like <code>guake</code>.</li>
  <li>It adds too much clutter that may not be useful, compared with a clean wall
paper of Gnome. I think Plasma 5.5 tries to fix this, but I did not have the
chance to try.</li>
</ol>

<p>As having been said, it must be the case I am not familiar with a new desktop
environment, but I guess I will settle with it, because after I was little
frustrated with the KDE desktop, I tried to switch back to Gnome. Suddenly,
everything started to work well! Maybe it is because I installed a lot of
libraries when I was installing KDE, which fixed some problems. But now I feel
current setting, the one I mentioned at the first section of this note,
awesome.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[On Environment Variable Setup of Linux]]></title>
    <link href="http://shawnLeeZX.github.io/blog/2016/01/05/on-environment-variable-setup-of-linux/"/>
    <updated>2016-01-05T11:28:00+08:00</updated>
    <id>http://shawnLeeZX.github.io/blog/2016/01/05/on-environment-variable-setup-of-linux</id>
    <content type="html"><![CDATA[<p>I have spent some time figuring out how Linux sets up its environment variables
for login shell, non-login shell to let Emacs inherits environment variables
and make tmux loads <code>.bashrc</code> and note it here.</p>

<!-- more -->

<h2 id="login-shell">Login Shell</h2>

<p>We start by figuring out the boot process.</p>

<p>For text console,</p>

<ol>
  <li>At the end of boot the mother of all processes <code>init</code> is started. init’s
environment, including PATH, is defined in its source code and cannot be
changed at run time.</li>
  <li><code>init</code> runs the start-up scripts from <code>/etc/init.d</code> depending on the run level
set in <code>/etc/inittab</code>. Since init’s environment is very bare, the scripts
define their required environment variables within themselves.</li>
  <li><code>init</code> starts the text login process that waits for the user to log in. When
the user logs in, the login process checks <code>/etc/passwd</code> to see what shell
should be started for this particular user.</li>
  <li>The shell starts and reads its shell-specific configuration files.
    <ol>
      <li>For Bash, it first reads <code>/etc/profile</code> to get values that are defined
for all users. After reading that file, it looks for <code>~/.bash_profile</code>,
<code>~/.bash_login</code>, and <code>~/.profile</code>, in that order, and reads and executes
commands from the first of these files that exists and is readable.</li>
    </ol>
  </li>
</ol>

<p>For graphical UI,</p>

<ol>
  <li>At the end of booting, the mother of all processes – <code>init</code> – is started.</li>
  <li><code>init</code> runs the start-up scripts from <code>/etc/init.d</code> depending on the run
level set in <code>/etc/inittab</code>. Since <code>init</code>’s environment is very bare, the
scripts define required environment variables within themselves.</li>
  <li>Init starts the GDM display manager, which in turn will start the graphical
login.</li>
  <li>When the user successfully logs in, GDM starts xsession, which reads the
file <code>/etc/gdm/Xsession</code> and with it the environment variables for the
user’s session. The default version of the Xsession file first reads
<code>/etc/profile</code> for global settings and then <code>~/.profile</code> to add the user’s
individual settings.</li>
</ol>

<p>The above boot process is the process to set up environment to login shell. So
if any user specific environment that is need for a graphical program, one
could choose to put it in <code>~/.bash_profile</code>, <code>~/.bash_login</code>, and
<code>~/.profile</code>. I chose to put it in <code>.profile</code>. I actually spent time figuring
this out, so Emacs could inherit environment variables the local libraries I
installed.</p>

<p>As for system wide setup, put it in <code>/etc/profile</code>.</p>

<h2 id="non-login-shell">Non-login Shell</h2>

<p>If a shell is needed after login, the setting should go to the non-login
shell’s, <code>.bashrc</code>. For instance, the terminals created by <code>terminal</code>,
<code>terminator</code> and other terminal programs are non-login shells. This is where I
previously put all my configurations in.</p>

<p>The following comes from <code>man bash</code>’s <em>INVOCATION</em> section.</p>

<pre><code>When bash is invoked as an interactive login shell, or as a non-interactive
shell with the `--login` option, it first reads and executes commands from the
file `/etc/profile`, if that file exists.  After reading that file, it looks
for `~/.bash_profile`, `~/.bash_login`, and `~/.profile`, in that order, and
reads and executes commands from the first one that exists and is readable.
The --noprofile option may be used when the shell is started to inhibit this
behavior.

When a login shell exits, bash reads and executes commands from the file
`~/.bash_logout`, if it exists.

When an interactive shell that is not a login shell is started, bash reads and
executes commands from `/etc/bash.bashrc` and `~/.bashrc`, if these files
exist.
</code></pre>

<h2 id="distribution">Distribution</h2>

<p>Each Linux distribution may tweak files mentioned above, for instance, unset
some variables somewhere, so if you set its value before where it is unset,
your setting will not take effect. Normally, if one’s configuration does not
work, consider go through all previous configurations and understand what they
exactly do in such a distribution.</p>

<h2 id="misc">Misc</h2>

<p>If one uses <code>tmux</code>, the terminal multiplexer, note it creates login shells. So
if one wants <code>.bashrc</code>, especially aliases, to work under <code>tmux</code>, remember to
source it after whatever login shell configuration one may use.</p>

<h2 id="reference">Reference</h2>

<ol>
  <li>https://wiki.debian.org/EnvironmentVariables</li>
  <li>https://help.ubuntu.com/community/EnvironmentVariables</li>
</ol>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Note On Compiling Tensorflow]]></title>
    <link href="http://shawnLeeZX.github.io/blog/2015/11/13/note-on-compiling-tensorflow/"/>
    <updated>2015-11-13T11:35:00+08:00</updated>
    <id>http://shawnLeeZX.github.io/blog/2015/11/13/note-on-compiling-tensorflow</id>
    <content type="html"><![CDATA[<p>A note on setting library path for cudnn when compiling tensorflow, in case I
forget it next time.</p>

<!-- more -->

<p>Directly providing the library path to cudnn, which has the following directory
structure,</p>

<p><code>bash
include  lib
</code></p>

<p>does not work.</p>

<p>According to the error message, it seems that the configuration tries to find
header file and shared libraries directly under the provided folder, thus this
time, I made another folder specifically for tensorflow — it is not in
<code>LD_LIBRARY</code>, so other programs do not use it — then the compilation works.</p>

<p>Since I just want to make sure I could get through the compilation process to
make sure if in case there are features not provided in the official binary, I
have a way to use it, I settled for now. But since the default folder is just
where CUDA lives, I guess if I made the directory structure of CUDNN the same
as CUDA, which I just need to add a symbol link <code>lib64</code> to <code>lib</code>, the
compilation may still work.</p>

<p>So this is the note.</p>

<hr />

<p>Updated on Jan 7, 2016</p>

<p>Adding a symbol link <code>lib64</code> to <code>lib</code> under where cudnn lives does work. The
folder structure is the one mentioned above.</p>
]]></content>
  </entry>
  
</feed>
