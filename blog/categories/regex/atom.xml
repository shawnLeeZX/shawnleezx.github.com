<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Regex | SHAWN LEE]]></title>
  <link href="http://shawnLeeZX.github.io/blog/categories/regex/atom.xml" rel="self"/>
  <link href="http://shawnLeeZX.github.io/"/>
  <updated>2016-03-15T11:40:00+08:00</updated>
  <id>http://shawnLeeZX.github.io/</id>
  <author>
    <name><![CDATA[Shawn]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Pattern of :grep and :vimgrep in Vim Explained]]></title>
    <link href="http://shawnLeeZX.github.io/blog/2014/03/15/pattern-of-grep-and-vimgrep-in-vim-explained/"/>
    <updated>2014-03-15T22:23:00+08:00</updated>
    <id>http://shawnLeeZX.github.io/blog/2014/03/15/pattern-of-grep-and-vimgrep-in-vim-explained</id>
    <content type="html"><![CDATA[<p>It has been a long time that I was confused with the different regex pattern
used by <code>:vimgrep</code> and <code>:grep</code> in Vim, especially for the double start <code>**</code>. Today
I read the help documentation of vim and write down their difference here.</p>

<p>Vim has two ways to do  the regex search, internally and externally. The former
uses the <code>:vimgrep</code> command while the latter uses the <code>:grep</code> command.
<code>:vimgrep</code> will read files into memory before doing regex search, thus it is
slower than <code>:grep</code>, which uses the external grep program, specified using
<code>grepprg</code> parameter.</p>

<!-- more -->

<p>Therefore, the regex of <code>:grep</code> is the same with normal grep command you are
using in bash while the regex of <code>:vimgrep</code> uses the vim regex pattern. The
most obvious difference for me is the double star wildcard usage.</p>

<p>Vim regex pattern supports <strong>starstar-wildcard</strong>. For example:</p>

<p><code>bash
Example: &gt;
	:n **/*.txt
Finds files:
	ttt.txt
	subdir/ttt.txt
	a/b/c/d/ttt.txt
When non-wildcard characters are used these are only matched in the first
directory.  Example: &gt;
	:n /usr/inc**/*.h
Finds files:
	/usr/include/types.h
	/usr/include/sys/types.h
	/usr/inc_old/types.h
</code></p>

<p><code>:grep</code> will only take <code>**</code> as one <code>*</code> and ignore the next <code>*</code>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Non Greedy Regex]]></title>
    <link href="http://shawnLeeZX.github.io/blog/2013/11/19/non-greedy-regex/"/>
    <updated>2013-11-19T10:16:00+08:00</updated>
    <id>http://shawnLeeZX.github.io/blog/2013/11/19/non-greedy-regex</id>
    <content type="html"><![CDATA[<h2 id="my-re-isnt-matchingdeleting-what-i-want-it-to-or-greedy-vs-stingy-pattern-matching">My RE isn’t matching/deleting what I want it to. (Or, “Greedy vs. stingy pattern matching”)</h2>

<p>The two most common causes for this problem are: </p>

<ol>
  <li>misusing the ‘.’
metacharacter</li>
  <li>misusing the ‘*’ metacharacter.</li>
</ol>

<p>The RE ‘.*’ is designed to be “greedy” (i.e., matching as many characters as
possible). However, sometimes users need an expression which is “stingy,”
matching the shortest possible string.</p>

<!-- more -->

<h2 id="misusing-the--metacharacter">misusing the ‘.’ metacharacter</h2>

<p>On single-line patterns, the ‘.’ metacharacter matches any single character on the line. (‘.’ cannot match the newline at the end of the line because the newline is removed when the line is put into the pattern space; sed adds a newline automatically when the pattern space is printed.) On multi-line patterns obtained with the ‘N’ or ‘G’ commands, ‘.’ will match a newline in the middle of the pattern space. If there are 3 lines in the pattern space, “s/.*//” will delete all 3 lines, not just the first one (leaving 1 blank line, since the trailing newline is added to the output).</p>

<p>Normal misuse of ‘.’ occurs in trying to match a word or bounded field, and forgetting that ‘.’ will also cross the field limits. Suppose you want to delete the first word in braces:</p>

<pre><code>   echo {one} {two} {three} | sed 's/{.\*}/{}/'       # fails
   echo {one} {two} {three} | sed 's/{[^}]\*}/{}/'    # succeeds 's/{.\*}/{}/' is not the solution, since the regex '.' will match any character, including the close braces. Replace the '.' with '[^}]', which signifies a negated character set '[^...]' containing anything other than a right brace. FWIW, we know that 's/{one}/{}/' would also solve our question, but we're trying to illustrate the use of the negated character set: [^anything-but-this].
</code></pre>

<p>A negated character set should be used for matching words between quote marks, for fields separated by commas, and so on. See also section 4.12 (“How do I parse a comma-delimited data file?”).</p>

<h2 id="misusing-the--metacharacter-1">misusing the ‘*’ metacharacter</h2>

<p>The ‘*’ metacharacter represents zero or more instances of the previous expression. The ‘*’ metacharacter looks for the leftmost possible match first and will match zero characters. Thus,</p>

<pre><code>   echo foo | sed 's/o\*/EEE/' will generate 'EEEfoo', not 'fEEE' as one might expect. This is because /o\*/ matches the null string at the beginning of the word.
</code></pre>

<p>After finding the leftmost possible match, the ‘*’ is GREEDY; it always tries to match the longest possible string. When two or three instances of ‘.*’ occur in the same RE, the leftmost instance will grab the most characters. Consider this example, which uses grouping ‘(…)’ to save patterns:</p>

<pre><code>   echo bar bat bay bet bit | sed 's/^.\*\(b.\*\)/\1/' What will be displayed is 'bit', never anything longer, because the leftmost '.\*' took the longest possible match. Remember this rule: "leftmost match, longest possible string, zero also matches."
</code></pre>

<p>from: http://sed.sourceforge.net/sedfaq5.html</p>
]]></content>
  </entry>
  
</feed>
